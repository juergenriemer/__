"undefined"==typeof __&&(__={});__.Async=function(a){var b="Async"+ ++__.Async.ix;a=a||{};a.__guid_async__=b;return __.Async.store[b]=new __.Async.Promise(a)};__.Async.ix=0;__.Async.store={};__.Async.fnerr=function(a,b){console.log("[error]",a,b)};__.Async.fnstat=function(){};__.Async.promise=function(a){var b=null;"object"==typeof a&&a.__guid_async__?b=__.Async.store[a.__guid_async__]:(b=new __.Async,b.__cb__=a&&a.cb?a.cb:function(a){console.log(a)});b.bLateArrivals=!0;return b};
__.Async.Promise=function(a){this.__guid_async__=a.__guid_async__;this._sStatus="idle";this._args={__guid_async__:this.__guid_async__};this._loTasks=[];this._bDebug=!1;this.ctx=a&&a.ctx?a.ctx:window;this.id=a&&a.id?a.id:this.__guid_async__;this.sdftError=a&&a.sdftError?a.sdftError:"";this.fnerr=a&&a.fnerr?a.fnerr:__.Async.fnerr;this.fnstat=a&&a.fnstat?a.fnstat:__.Async.fnstat;return this};
__.Async.Promise.prototype={c:0,ix:0,bLateArrivals:!1,debug:function(){this._bDebug=!0;return this},clear:function(){var a=this;this._add({ctx:this.ctx,sfn:function(){a._args={__guid_async__:a.__guid_async__};a.resolve()},args:{}});return this},pause:function(a,b){var c=this;this._add({ctx:this.ctx,sfn:function(){setTimeout(function(){c.resolve()},a)},args:{},sMsg:b||"pause"});return this},wait:function(a,b,c){var d=this,e="number"==typeof b?b:25;this._add({ctx:this.ctx,sfn:function(){var b=function(){a()?
d.resolve():setTimeout(b,e)};b()},args:{},sMsg:"string"==typeof b?b:c?c:"wait"});return this},parallel:function(a,b){var c=this._args;this.then(function(){var b=__.Async.promise(c),e=a.length;a.forEach(function(a){a.then(function(d){delete d.__guid_async__;for(var f in d)c[f]=d[f];0==--e&&b.resolve();a.resolve()},"done");a.start()})},b||"");return this},then:function(a,b,c,d){this._add({ctx:"object"==typeof a?a:this.ctx,sfn:"object"==typeof a?b:a,args:"string"==typeof b?"object"==typeof c?c:{}:b?
b:{},sMsg:"object"==typeof c?d:"string"==typeof c?c:"string"==typeof b?b:""});return this},_add:function(a){this.c++;a.__guid_async__=this.__guid_async__;if(this.bLateArrivals){a.bLateArrival=!0;var b=this._loTasks.length;if(b){for(var c=0;c<b;c++){var d=!1;if(!this._loTasks[c].bLateArrival){d=!0;this._loTasks.splice(c,0,a);break}}d||this._loTasks.push(a)}else this._loTasks.push(a)}else this._loTasks.push(a)},_stats:function(a){var b=this.fnstat;this._bDebug&&(b=function(a){console.log(a.__guid_async__+
" ("+a.ix+"/"+a.c+") -> "+a.sMsg)});b&&b({__guid_async__:this.__guid_async__,sMsg:a||"",c:this.c,ix:this.ix,pct:100*this.ix/this.c})},_next:function(){var a=this._loTasks.shift();this.scurMsg=a.sMsg;this.ix++;this._stats(a.sMsg);for(var b in a.args){var c=a.args[b];if("object"==typeof c&&c&&c.arg){var d=c.arg.split(".");c=this._args;d.forEach(function(a){c=c[a]})}this._args[b]=c}if("string"==typeof a.sfn)a.ctx[a.sfn](this._args);else a.sfn.call(a.ctx,this._args)},start:function(){this._sStatus="pending";
this._next();return this},resolve:function(a){this.bLateArrivals=!1;this._loTasks.forEach(function(a){a.bLateArrival=!1});for(var b in a)this._args[b]=a[b];0<this._loTasks.length?this._next():(this._sStatus="idle",this._cleanUp(),this.__cb__&&this.__cb__(a))},stop:function(){this._cleanUp()},reject:function(a){var b=function(a){try{return a?JSON.stringify(a):"na"}catch(e){return"could not stringify"}};this._sStatus="error";a="string"==typeof a?a:"object"==typeof a?a.sError?a.sError:"A task was rejected":
"A task was rejected";var c="id:("+this.id+") ";c+="task:("+this.scurMsg+") ";c+="args:("+b(this._args)+") ";c+="sdftError:("+this.sdftError+") ";c+="sError:("+b(a)+") ";b={ix:this.ix,id:this.id,sErrorTask:this.scurMsg,args:this._args,sdftError:this.sdftError,sError:a,sStack:c};this.fnerr&&this.fnerr(b)},_cleanUp:function(){this._bDebug||delete __.Async.store[this.__guid_async__]}};
"undefined"==typeof __&&(__={});__.Class=function(){};__.Class.prototype.construct=function(){};
__.Class.extend=function(b){var a=function(){arguments[0]!==__.Class&&this.construct.apply(this,arguments)},c=new this(__.Class),f=this.prototype,d;for(d in b){var e=b[d];e instanceof Function&&(e.oParent=f,c.oParent=f,c._super=function(b){var a=arguments.callee.caller.arguments;return a.callee.oParent[b].apply(this,a)});c[d]=e}a.prototype=c;a.mixin=function(){[].slice.call(arguments).forEach(function(b){for(var a in b)c[a]||(c[a]=b[a])});return this};a.extend=this.extend;return a};
__.Class.instantiate=function(b,a){b=new b(a);b.init&&b.init(a);return b};
window.__css=function(a){var b=document.getElementsByTagName("head")[0],c=document.createElement("style");b.appendChild(c);c.innerHTML=a};Object.defineProperty(Array.prototype,"__each",{value:function(a){for(var b=this.length,c=0;c<b;c++)a(this[c])}});Object.defineProperty(Node.prototype,"__each",{value:function(a){a(this)}});
Object.defineProperty(Node.prototype,"__find",{value:function(a,b){var c="BODY"==this.tagName.toUpperCase()?document:this,d="querySelectorAll";if(/^.[a-zA-Z0-9_-]*$/.test(a)){var e=a.substr(0,1);"#"==e?(d="getElementById",a=a.substr(1)):"."==e?(d="getElementsByClassName",a=a.substr(1)):/[a-zA-Z]/.test(e)&&(d="getElementsByTagName")}if(a=c[d](a))if(a=Element.prototype.isPrototypeOf(a)?a:[].slice.call(a),b&&__.dn.each(a,b),b=a.length,!isNaN(b)){if(1==b)return a[0];if(0==b)return null}return a}});
Object.defineProperty(Node.prototype,"__remove",{value:function(){this.parentNode.removeChild(this)}});Object.defineProperty(Node.prototype,"__closest",{value:function(a,b){a=this.closest(a);b&&__.dn.each(a,b);return a}});Object.defineProperty(Node.prototype,"__append",{value:function(a,b){return __.dn._add_(a,this,b,"move")}});Object.defineProperty(Node.prototype,"__prepend",{value:function(a,b){return this.firstChild?__.dn._add_(a,this.firstChild,b,"_move"):__.dn._add_(a,this,b,"move")}});
Object.defineProperty(Node.prototype,"__before",{value:function(a,b){return __.dn._add_(a,this,b,"_move")}});Object.defineProperty(Node.prototype,"__after",{value:function(a,b){return __.dn._add_(a,this,b,"move_")}});Object.defineProperty(Node.prototype,"__show",{value:function(){var a=this.hasAttribute("__.display")?this.getAttribute("__.display"):"block";this.style.display=a}});
Object.defineProperty(Node.prototype,"__hide",{value:function(){if("none"!=this.style.display){var a=getComputedStyle(this).display;this.setAttribute("__.display",a);this.style.display="none"}}});Object.defineProperty(Node.prototype,"__h",{value:function(a){this.innerHTML=a}});Object.defineProperty(Node.prototype,"__ix",{value:function(){for(var a=0,b=this;null!=(b=b.previousElementSibling);)a++;return a}});
Object.defineProperty(Node.prototype,"__x",{value:function(a){if(a)/absolute|fixed/.test(self.getComputedStyle(this).position)||(this.style.position="absolute"),this.style.left=parseInt(a)+"px";else return this.getBoundingClientRect().left}});Object.defineProperty(Node.prototype,"__y",{value:function(a){if(a)/absolute|fixed/.test(self.getComputedStyle(this).position)||(this.style.position="absolute"),this.style.top=parseInt(a)+"px";else return this.getBoundingClientRect().top}});
Object.defineProperty(Node.prototype,"__dx",{value:function(a){if(a)this.style.width=parseInt(a)+"px";else return this.getBoundingClientRect().width}});Object.defineProperty(Node.prototype,"__dy",{value:function(a){if(a)this.style.height=parseInt(a)+"px";else return this.getBoundingClientRect().height}});Object.defineProperty(Node.prototype,"__style",{value:function(a,b){if(!b)return self.getComputedStyle(this)[a];this.style[a]=b}});
Object.defineProperty(Node.prototype,"__scrollTo",{value:function(a,b){switch(a){case "x":this.scrollLeft=b;break;case "y":this.scrollTop=b;break;case "bottom":this.scrollTop=this.scrollHeight;break;case "top":this.scrollTop=0;break;case "left":this.scrollLeft=0;break;case "right":this.scrollLeft=this.scrollWidth}}});
Object.defineProperty(Node.prototype,"__onScroll",{value:function(a,b){b=b||300;var c=this==document?document.body:this;this.__cbScroll=function(){c.__hd&&clearInterval(c.__hd);c.__hd=setTimeout(function(){var b=c.scrollHeight,e=c.scrollTop,f=c.clientHeight,h=c.scrollWidth,g=c.scrollLeft,k=c.clientWidth;a({x:g,y:e,dxcur:h,dycur:b,dy:f,dx:k,bTop:0==e,bBottom:e+f>=b,bLeft:0==g,bRight:g+k>=h})},b)};this.addEventListener("scroll",this.__cbScroll)}});
Object.defineProperty(Node.prototype,"__offScroll",{value:function(){this.removeEventListener("scroll",this.__cbScroll);this.__cbScroll=null}});"undefined"==typeof __&&(__={});
__.dn={each:function(a,b){if(a){a=isNaN(a.length)?[a]:a;for(var c=a.length,d=0;d<c;d++)b(a[d],d)}},h:function(a,b){b=b.toString()||"";var c=document.createElement("div");c.appendChild(document.createTextNode(b));a.innerHTML=c.innerHTML},_move:function(a,b){a instanceof Array?__.dn.each(a,function(a){b.parentNode.insertBefore(a,b)}):b.parentNode.insertBefore(a,b)},move:function(a,b){a instanceof Array?__.dn.each(a,function(a){b.appendChild(a)}):b.appendChild(a)},move_:function(a,b){a instanceof Array?
__.dn.each(a,function(a){b.parentNode.insertBefore(a,b.nextSibling);b=a}):b.parentNode.insertBefore(a,b.nextSibling)},_add_:function(a,b,c,d){var e="object"==typeof b?b:document.body;b="function"==typeof b?b:c;var f=document.createElement("div");"string"==typeof a?f.innerHTML=a:a.length?__.dn.each(a,function(a){f.appendChild(a)}):f.appendChild(a);a=[].slice.call(f.children);a=a instanceof Array&&1==a.length?a[0]:a;b&&__.dn.each(a,b);__.dn[d](a,e);return a}};
Object.defineProperty(Node.prototype,"__fadeOut",{value:function(a){this.classList.add("__effects");this.style.opacity=0;a&&setTimeout(function(){a(this)},501);return this}});Object.defineProperty(Node.prototype,"__fadeIn",{value:function(a){this.classList.add("__effects");this.style.opacity=1;a&&setTimeout(function(){a(this)},501);return this}});
Object.defineProperty(Node.prototype,"__slideDown",{value:function(a){this.classList.add("__effects");this.style.overflowY="hidden";var b=parseInt(this.scrollHeight);if(0==b)return this;this.style.maxHeight=b;for(var c=this;"BODY"!==c.tagName;)c=c.parentNode,c.hasAttribute("ls-slide")&&(c.style.maxHeight=c.scrollHeight+b);this.setAttribute("ls-slide",!0);a&&setTimeout(a,301);return this}});
Object.defineProperty(Node.prototype,"__slideUp",{value:function(a){this.classList.add("__effects");this.style.overflowY="hidden";var b=this,c=b.scrollHeight;if(0==c)return this;b.style.maxHeight=c;setTimeout(function(){b.style.maxHeight=0;for(var d=b;"BODY"!==d.tagName;)d=d.parentNode,d.hasAttribute("ls-slide")&&(d.style.maxHeight=d.scrollHeight-c);a&&setTimeout(a,301)},0);return this}});
(function(){var a=".__effects { ",b="opacity 0.3s ease-in-out";b+=", max-height 0.3s ease-in-out";["-webkit-","-moz-","-o-",""].forEach(function(c){a+=c+"transition:"+b+";"});a+=" } ";__css(a)})();this.Element&&function(a){a.matches=a.matches||a.matchesSelector||a.webkitMatchesSelector||a.msMatchesSelector||function(a){a=(this.parentNode||this.document).querySelectorAll(a);for(var b=-1;a[++b]&&a[b]!=this;);return a[b]?!0:!1}}(Element.prototype);
this.Element&&function(a){a.closest=a.closest||function(a){for(var b=this;b.matches&&!b.matches(a);)b=b.parentNode;return b.matches?b:null}}(Element.prototype);(function(){})();window.__find=function(a,b){return document.body.__find(a,b)};window.__append=function(a,b){return document.body.__append(a,b)};window.__prepend=function(a,b){return document.body.__prepend(a,b)};window.__style=function(a,b){return document.body.__style(a,b)};window.__scrollTo=function(a,b){document.body.__scrollTo(a,b)};
window.__onScroll=function(a,b){document.__onScroll(a,b)};window.__offScroll=function(){document.__offScroll()};
"undefined"==typeof __&&(__={});
__.Event={oListeners:{},sEvent:function(a){var c=[];a.split(" ").forEach(function(a,b){a&&c.push(a.substr(0,1).toUpperCase()+a.substr(1))});return"on"+c.join("")},setScroll:function(){var a=this;__onScroll(function(c){a.trigger("scroll",c)})},listen:function(){var a=this,c=Array.prototype.slice.call(arguments),d=c.shift();c.forEach(function(b){"scroll"==b&&a.setScroll();b=a.sEvent(b);a.oListeners[b]||(a.oListeners[b]=[]);a.oListeners[b].push(d)})},trigger:function(a,c){a=this.sEvent(a);var d=this.oListeners[a];
d&&d.forEach(function(b){if("function"==typeof b[a])b[a](c);else console.warn("listener has no trigger receiver: "+a)})}};
"undefined"==typeof __&&(__={});Object.defineProperty(String.prototype,"__toJson",{value:function(){try{return JSON.parse(this)}catch(a){return null}}});Object.defineProperty(String.prototype,"__isEmpty",{value:function(){return""===this.trim()}});
Object.defineProperty(String.prototype,"__toCamelCase",{value:function(){var a=[],b=function(a){return a.substr(0,1).toUpperCase()+a.substr(1)};this.split(" ").forEach(function(c,f){if(c)if(/-/.test(c)){var g=[];c.split("-").forEach(function(a){g.push(b(a))});a.push(g.join("-"))}else a.push(b(c))});return a.join(" ")}});Object.defineProperty(String.prototype,"__unCamelCase",{value:function(){s=this.replace(/([A-Z])([a-z])/g," $1$2");s=s.replace(/([a-z])([A-Z])/g,"$1 $2");return s.trim()}});
Object.defineProperty(String.prototype,"__tokenize",{value:function(a){var b=this;return a&&"simple"!=a?b:(b=b.replace(/\s/g,""),b=b.replace(/'/g,""),b=b.replace(/"/g,""),b.toLowerCase())}});Object.defineProperty(String.prototype,"__isEmail",{value:function(){return/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+[\.]{1}[a-zA-Z]{2,4}$/.test(this)}});Object.defineProperty(String.prototype,"__isUrl",{value:function(){return/^(http|https):\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(this)}});
Object.defineProperty(Object.prototype,"__toString",{value:function(){try{return JSON.stringify(this)}catch(a){return null}}});
Object.defineProperty(Object.prototype,"__struc",{value:function(){function a(c,e){for(var d in c)if(c[d]&&c[d].sort&&c[d].sort(b).sort(),c.hasOwnProperty(d)){var f=e?".":"";g.push(e+f+d);"object"==typeof c[d]&&a(c[d],e+f+d)}}var b=function(a,b){a=a&&a.sort?a.sort():a;b=b&&b.sort?b.sort():b;return a>b},c=this.__toString(),f=c.length;(c=c.__toJson())&&c.sort&&c.sort(b).sort();var g=[];a(c,"");return{o:c,nLength:f,lsStruc:g.sort()}}});Object.defineProperty(Object.prototype,"__equal",{value:function(a){return this.__compareTo(a).isEqual}});
Object.defineProperty(Object.prototype,"__compareTo",{value:function(a){var b=!0,c=[],f=this.__struc(),g=a.__struc();f.nLength!==g.nLength&&(c.push(["length",,f.nLength,g.nLength]),b=!1);f.lsStruc.forEach(function(a){for(var e=f.o,d=g.o,k=a.split("."),h=0;h<k.length;h++)if(e=e?e[k[h]]:e,d=d?d[k[h]]:d,typeof e!==typeof d){c.push(["type",a,e,d]);b=!1;break}else if("undefined"===typeof d){c.push(["miss",a,e,d]);b=!1;break}else e instanceof Date||e instanceof Function?(e=e.toString().replace(/\s/g,""),
d=d.toString().replace(/\s/g,"")):"object"!==typeof e&&e!==d&&(b=!1,c.push(["diff",a,e,d]))});return{isEqual:b,ldiff:c}}});Object.defineProperty(Object.prototype,"__diff",{value:function(a){var b=this.__compareTo(a);if(b.isEqual)return null;a=a.__compareTo(this);return{o1:b.ldiff,o2:a.ldiff}}});Object.defineProperty(Object.prototype,"__getKey",{value:function(){for(var a in this)return a;return null}});
Object.defineProperty(Object.prototype,"__getKeys",{value:function(){if(Object&&Object.keys)return Object.keys(this);var a=[],b;for(b in this)a.push(b);return a}});Object.defineProperty(Object.prototype,"__add",{value:function(a){if(a)for(var b in a)this[b]=a[b]}});Object.defineProperty(Object.prototype,"__kRename",{value:function(a,b){Object.defineProperty(this,b,Object.getOwnPropertyDescriptor(this,a));delete this[a]}});
Object.defineProperty(Object.prototype,"__kCount",{value:function(){var a=0,b;for(b in this)this.hasOwnProperty(b)&&++a;return a}});Object.defineProperty(Object.prototype,"__copy",{value:function(){try{return JSON.parse(JSON.stringify(this))}catch(a){return null}}});Object.defineProperty(Object.prototype,"__isEmpty",{value:function(){for(var a in this)return!1;return!0}});Object.defineProperty(Number.prototype,"__withinBoundary",{value:function(a,b){var c=this;c=c<a?a:c;return c>b?b:c}});
Object.defineProperty(String.prototype,"__sanitize",{value:function(){us_h=this.toString()||"";var a=document.createElement("div");a.appendChild(document.createTextNode(us_h));return a.innerHTML}});Object.defineProperty(Array.prototype,"__remove",{value:function(a){var b=this.indexOf(a);-1<b&&(this.splice(b,1),this.__remove(a))}});Object.defineProperty(Array.prototype,"__contains",{value:function(a){return-1<this.indexOf(a)}});
Object.defineProperty(Array.prototype,"__empty",{value:function(){return 0==this.length}});Object.defineProperty(Array.prototype,"__kSort",{value:function(a){return this.sort(function(b,c){return b.hasOwnProperty(a)&&"undefined"!=typeof b[a]?!c.hasOwnProperty(a)||"undefined"==typeof c[a]||b[a]<c[a]?-1:b[a]>c[a]?1:0:1})}});__.css=function(a){var b=document.createElement("style");document.body.appendChild(b);b.innerHTML=a};
__.cookie={get:function(a){return(a=document.cookie.match("(^|;) ?"+a+"=([^;]*)(;|$)"))?a[2]:null},set:function(a,b,c){var f=new Date;f.setTime(f.getTime()+864E5*c);document.cookie=a+"="+b+";path=/;expires="+f.toGMTString()},remove:function(a){__.cookie.set(a,"",-1)}};__.url={oParams:function(a){var b={};(a?a:window.location.href).replace(/[?&]+([^=&]+)=([^&]*)/gi,function(a,f,g){b[f]=g});return b}};__.utils={};
__.utils.dt={date:function(a){a="object"==typeof a?a:"string"==typeof a?new Date(a.replace(/\D/g,"-")):new Date;var b=a.getDate(),c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")[a.getDay()],f=c.substring(0,3),g=a.getMonth(),n="January February March April May June July August September October November December".split(" ")[g],e=n.substring(0,3),d=a.getFullYear(),k=a.getHours?a.getHours():0,h=a.getMinutes?a.getMinutes():0,m=a.getSeconds?a.getSeconds():0,p=10>k?"0"+k:k,q=10>
h?"0"+h:h,r=10>m?"0"+m:m,t=[e,b,d].join(" ")+" "+[p,q].join(":");return{nDay:b,sDay:c,sDayShort:f,nMonth:g,sMonth:n,sMonthShort:e,nYear:d,nHour:k,nMinute:h,nSecond:m,sHour:p,sMinute:q,sSecond:r,sdtdft:t,dt:a}},diff:function(a,b){b=b||new Date;b.getTime();a.getTime();a=a.getTime()-b.getTime();return Math.ceil(a/864E5)}};__.utils.misc={isIE:function(){return"Microsoft Internet Explorer"==navigator.appName?!0:"Netscape"==navigator.appName?-1<navigator.appVersion.indexOf("Edge"):!1}};
if( typeof( __ ) == "undefined" ) {
	__ = {};
}

//__.css( '.-ac-content{background : #fff;z-index : 999;cursor : pointer;border-left : 1px solid #c0c0c0;border-right : 1px solid #c0c0c0;border-bottom : 1px solid #c0c0c0;} .-ac-content .-ac-highlight,.-ac-content .-ac-row:hover{background : #efefef;color : #a0a0a0;} .-ac-content .line{padding : 0.4em;border-bottom : 1px dotted #efefef;} .-ac-content .left img{height : 37px;width : 27px;float : left;} .-ac-content .right{margin-left : 33px;} .-ac-content .right .title{font-weight : bold;font-size : 1.1em;} .-ac-inactive {color : #a0a0a0 !important;cursor : default;} .-ac-loading{background-image: url("data:image/gif;base64,R0lGODlhHwAfAPUgAOjo6NLS0ry8vK6urqKiotzc3Li4uJqamuTk5NjY2KqqqqCgoLCwsMzMzPb29qioqNTU1Obm5jY2NiYmJlBQUMTExHBwcJKSklZWVvr6+mhoaEZGRsbGxvj4+EhISDIyMv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh/hpDcmVhdGVkIHdpdGggYWpheGxvYWQuaW5mbwAh+QQJCgAgACwAAAAAHwAfAAAG/0CQcEgEBAQDAkhCsRwaxKh0WDAcrlfQZLvVMDpTKUKALWu5XAsnPEwoymY02qNggxbwuJz7CScWIHlYZ3sTdwlRCG8HgVgMDQgOIAAVFxhojQoIRGSDBw8QYRkEG4ZlAlR5IJt2a3kFQlZlDxF2QxEPcAaTeaG2QxB5RnAMv1EMcEdwUMZDDXBIcKzNq3BJcJLUIA5wStrNBNjf3GUEA9LfCNadWMzUz6cBxN/IZQEAvdTBcAAgsli0jOHSJaSAqmlhNr0awo7RJ19TIORqdAXVEEVZyjyKtA1Bg3oZD2iK8oeiKkFZFiCaggelSTiA2LhxiVLBSjZjBL2siNBOFQ84Lw3A+mYEiRJzAu7ZCQIAIfkECQoAIAAsAAAAAB8AHwAABv9AkHBIBAQEAwKIMBAEAMSodFgwHK5XEPZqKEynCMEWqx0fBIjvMKEwZ90HRUINWsAPZffim9jf82YgHwpRCG14WwwNCA4gDggNDFsgExMeHERiZAcPEGoQD3iVlRYdQgWBaXRpo6MMQlZbDxF0QxwbrRMaIABmnrVDBLkTDQFjr8BDGRi5Z2MNyUQXuRYDY6rRIBW5FARjjdm8uRLh2d5b4NkOY0zX5QhjTc/lDWNOx+WSW0++2RBmUGJhmZUsQqgtBk6lqpXGjBchmt50+hQKkAAiht5gUcTIESR9GhVgE9IH0BiTkxbMmWIHDkose9SwcQlHDsOIk9ygiVbl5JgMLuV4HUmypMkTOkEAACH5BAkKACAALAAAAAAfAB8AAAb/QJBwSAQEBAMCiDAQBADEqHRYMByuVxD2aihMpwjBFqsdHwSI7zChMGfdB0VCDVrAD2X34pvY3/NmdXNECG14WwwNCA4gDggNDFtlCmlDYmQHDxBqEA+HWAJUgZVqaWZeIFZbDxF0QxGeWwYgAGabrkMQZkZjDLhRkVtHYw2/RA1jSGOkxghjSWOMxkIOY0rT0wTR2LQT3t4SA8vcFd/eFJdYxdgX5hMWAb3YGRjuB7Vjt78E7hPFqlhY/eKwwZ0GIQVGuUrTz5eQdIc0cfIEwpyFDkMKvcGSaFGjR8GyePPAIUofQGNQSvqg4IsdOCqx7FHDBiYcOQshYjKDxliVDpRjunCjdSTJkiZP6AQBACH5BAkKACAALAAAAAAfAB8AAAb/QJBwSAQEBAMCiDAQBADEqHRYMByuVxD2aihMpwjBFqsdHwSI7zChMGfdB0VCDVrAD2X34pvY3/NmdXNECG14WwwNCA4gDggNDFtlCmlDYmQHDxBqEA+HWAJUgZVqaWZeIFZbDxF0QxGeWwYgAGabrkMQZkZjDLhRkVtHYw2/RA1jSGOkxghjSWOMxkIOY0rT0wTR2I3WA8vczltNxNzIW0693MFYT7bTumNQqlisv7BjsyAFo64cgFdQgbj0RtOXDAQ2TAAUakihN1gSLaJV4QKGCRgXXqEUpQ9ASRlDYhT0xQ4cECJDfqDD5mRKjB4UuArjBmVKC/9+VRljM6MGDwYduBlBokQCBQsHiqkJAgAh+QQJCgAgACwAAAAAHwAfAAAG/0CQcEgEBAQDAogwEAQAxKh0WDAcrlcQ9mooTKcIwRarHR8EiO8woTBn3QdFQg1awA9l9+Kb2N/zZnVzRAhteFsMDQgOIA4IDQxbZQppQ2JkBw8QahAPh1gCVIGVamlmXiBWWw8RdEMRnlsGIABmm65DEGZGYwy4UZFbR2MNv0QNY0hjpMYIY0ljjMZCDmNK09ME0diN1gPL3M5bTcTcyFtOvdzBWE+207pjUKpYrL+wY7MgBYEcrqZjUIG4lGXCBgIZvnT6dCXUkEIFJ0jEcKECFEeQJF2hFKUPCIkgQwIaI+jLh5AoR27Zo0aBB5QgVW4cpIaDBZgTZKL51YGBhg+U+QROQ2aBgoQlTZ7QCQIAIfkECQoAIAAsAAAAAB8AHwAABv9AkHBIBAQEAwKIMBAEAMSodFgwHK5XEPZqKEynCMEWqx0fBIjvMKEwZ90HRUINWsAPZffim9jf82Z1c0QIbXhbDA0IDiAOCA0MW2UKaUNiZAcPEGoQD4dYAlSBlWppZl4gVlsPEXRDEZ5bBiAAZpuuQxBmRmMMuFGRW0djDb9EDWNIY6TGCGNJY4zGQg5jStPTEhPb21DY1VsEFNzbFdggzlsDFuQTF+fIW2LtGBnYwVgBDe0T17+6Y6BoaLeBwy9YY2aBYMAPnStTY1B1YMdNiyZOngCFGsLBwzZAiRY1eoTvE6UoCj4AGrNS0oJBUuzAaYlljxo2M+HIeXiJpRsRNMaq+JSFCpsRJEqYOPH2JQgAIfkECQoAIAAsAAAAAB8AHwAABv9AkHBIBAQEAwKIMBAEAMSodFgwHK5XEPZqKEynCMEWqx0fBIjvMKEwZ90HRUINWsAPZffiq/jkzX9jdXNEHB4TE38MDQgOIA4IDQxbZQppQh0WiIhaDxBqEA94WwJDDJubIJdqaWZeIBqoExscdEMRolsGIA2yE0q2QxBmAAeyGBnBRJNbAZqoF8pEDWMCFLIV0kMIYwMSslDaj2PA4soEY47iDuQDY6vS3FtNYw3m1KQBYwzmzFhPZj5JGzYGipUtDyIowzVmF4gCgOCBCXTgFQgxZA54AiXqT6ltbUZhWdToUSR/Ii1FSbDnDkUyCwhJsQPn5ZU9atjUhCPHVhgTNy/RSKsiqKFFbUaQKGHiJNyXIAAh+QQFCgAgACwAAAAAHwAfAAAG/0CQcEhsHCwUCYgwEAQAxKhU2GFoJlgs6MDlGgrTKceSLW+7XQEiPFR4ymY0WpFggz7wuLy7CCf6eVlnewcgC3VECApcIGUYFxVQDggNDGhnCmtDApcTGwQZYRAPhWgCQwV7IBx2IGt7YCAGcg8RrUIRpGgGIAB7ELdDEHsAAXIMwUSWaAGcaA3JQ0amA3Ka0QhyAwRyDtFCDnIE39HcaN7f4WhM1uTZaE1y0N/TacZoyN/LXU+/0cNyoMxCUytYLjm8QKSS46rVKzmxQDhjdOABMFGkBh04NUQRxS4MGiDwNqnSJS6ZovzRyJAQo0NhFrgs5bIPmwSLCLHsQsfhxBWTe9QkKzCwC8sv5Ho127akyRM7QQAAOw==");background-position-x : 100% !important;background-position-y : 0% !important;background-size : auto 100% !important;background-repeat : no-repeat !important;} ');

__.autocomplete = {
	/* {
		dn : DOM node of input field
		sField : field to use to update input field on select
		hTemplate : Mustache template
		fnFetch : function to fetch data will be called with sTerm and cbfn parameters
		cb : callback on selection
	} */
	  init : function( a ) {
		if( a.dn.tagName !== "INPUT" ) {
			console.warn( "autocomplete missing input field" );
			return;
		}
		if( ! a.hTemplate ) {
		//	console.warn( "autocomplete missing template" );
		//	return;
		}
		if( ! a.fnFetch ) {
			console.warn( "autocomplete missing function to fetch data" );
			return;
		}
		if( a.dn.ix ) {
			// we already attached autocomplete
			return;
		}
		if( ! a.hTemplate ) {
// test this.. class names are not -ac do we need class here at all?
			var h = '<div class="line">';
			h += '<div class="title">{{' + a.sField + '}}</div>';
			h += '</div>';
			a.hTemplate = h;
		}
		a.lsInactive = a.lsInactive || [];
		// first we flag the input field with a classname used to get
		// all active autocompletes e.g. for when the browser resizes
		a.dn.classList.add( "-ac" );
		// add "autocomplete" off for certain field names are
		// automatically added autocomplete (e.g. chrome + "author")
		a.dn.autocomplete = "off";
		// create and assign HTML fragment to DOM node
		a.dnList = a.dn.__after( this.hCreate() );
		//xxx a.dnList = __.dn.frag( this.hCreate() );
		//xxx __.dn.insertAfter( a.dnList, a.dn );
		// apply events
		this.events( a );
	}
	, msDelay : 500
	, style : function( a ) {
	}
	, fetch : function( a, sTerm ) {
		var that = this;
		if( a.dnList.hdDelay ) {
			clearTimeout( a.dnList.hdDelay );
		}
		a.dnList.hdDelay = setTimeout( function() {
			a.dn.classList.add( "-ac-loading" );
			a.fnFetch( sTerm, function( oResult ) {
				if( a.dn.classList.contains( "-ac-active" ) ) {
					that.render( a, oResult );
				}
			} );
		}, that.msDelay );
	}
	, events : function( a ) {
		var that = this;
		a.dn.ix = 0;
		a.dnList.addEventListener( "click", function( e ) {
			__.e.stop( e );
			var dn = e.target;
			if( ! dn.classList.contains( "-ac-row" ) ) {
				//dn = __.dn.up( dn, "className", "-ac-row" );
				dn = dn.__closest( ".-ac-row" );
			}
			var ixRow = dn.__ix() + 1;
			that.highlight( a, ixRow );
			that.select( a );
		} );
		a.dn.addEventListener( "keydown", function( e ) {
			if( e.keyCode == "13" ) {
				__.e.stop( e );
				that.select( a );
			}
		} );
		a.dn.addEventListener( "keyup", function( e ) {
			var dn = e.target;
			if( e.keyCode == "38" ) {
				that.highlight( a, Number( a.dn.ix ) - 1 );
			}
			else if( e.keyCode == "40" ) {
				that.highlight( a, Number( a.dn.ix ) + 1 );
			}
			else if( e.keyCode == "27" ) {
				that.close( a, false );
			}
			else {
				// fetch terms from service
				var sTerm = dn.value;
				that.fetch( a, sTerm );
			}
		} );
		a.dn.addEventListener( "blur", function( e ) {
			__.e.stop( e );
			// close if input field loses focus
			// we need to delay this action after a possible
			// click event had been processed
			setTimeout( function() {
				that.close( a, false );
			}, 250 );
		} );
		a.dn.addEventListener( "focus", function( e ) {
			var dn = e.target;
			// we have focus on the node, i.e we can activate
			// the autocomplete
			a.dn.classList.add( "-ac-active" );
			// if the input field gets focus check if we 
			// should perform a query without typing first
			if( a.bInitLoad ) {
				// fetch term, avoiding hint text being used
				var sTerm = ( dn.classList.contains( '-fh-hinted' ) )
					? "" : dn.value;	
				// fetch terms from service
				that.fetch( a, sTerm );
			}
		} );
	}
	, highlight : function( a, ix ) {
		a.dn.ix = ix.__withinBoundary( 0, a.c );
		var ldnLines = a.dnList.__find( ".-ac-highlight" );
		__.dn.each( ldnLines, function( dn ) {
			dn.classList.remove( "-ac-highlight" );
		} );
		if( ldnLines && a.dn.ix > 0 ) {
			var scur = ".-ac-row:nth-child(" + a.dn.ix + ")"; 
			var dncurLine = a.dnList.__find( scur );
			dncurLine.classList.add( "-ac-highlight" );
		}
	}
	, select : function( a ) {
		// default value is blank
		var v = "";
		// if a field name is set...
		if( a.sField ) {
			// first get the index
		    	var ix = a.dn.ix - 1;
			// let check if we have a data object
			if( a.dn.oResult &&
			    a.dn.oResult.length && 
			    a.dn.oResult[ ix ] ) {
				// get selected data object
				var rec = a.dn.oResult[ ix ];
				// ... we update the input field value with it
				v = ( rec ) ? rec[ a.sField ] : "";
			}
		}
		// set value in input field
		if( ! a.bClearOnSelect ) {
			// if not clear on select
			a.dn.value = v;
		}
		else {
			// otherwise blank
			a.dn.value = "";
		}
		// if a callback is set...
		if( typeof a.cb == "function" ) {
			// we invoke it with the entire record object
			a.cb( rec );
		}
		// finally we hide the list
		this.close( a, true );
	}
	, close : function( a, bSelected ) {
//return;
		// remove active class, which also prevents ajax responses
		// still hanging to open it again
		a.dn.classList.remove( "-ac-active" );
		// hide loader
		a.dn.classList.remove( "-ac-loading" );
		// first check if list is already empty
		if( a.dnList.innerHTML == "" ) {
			// in which case it had already been closed
			// we simply return
			return;
		}
		// hide the list
		a.dnList.__hide();
		// empty it
		a.dnList.innerHTML = "";
		// and reset the highlight index
		a.dn.ix = 0;
		if( ! bSelected ) {
			// blank input field if not just selected
			a.dn.value = "";
		}
		// re-activate hint if set
		if( a.dn.hasAttribute( "ls-hint" ) ) {
			__.formhint.blur( a.dn );
			a.dn.blur();
		}
	}
	, render : function( a, oResult ) {
		// first remove the loading animation
		a.dn.classList.remove( "-ac-loading" );
		// we got some results
		if( oResult && oResult.length ) {
			// set number of results needed for navigation
			a.c = oResult.length;
			// attach the result object to input field for
			// later extraction of selected field
			a.dn.oResult = oResult;
		}
		var h = "{{#lrecs}}" + a.hTemplate + "{{/lrecs}}";
		var aData = {
			  lrecs : oResult
		};
		// construct content with mustache within a wrapper node
		// that is absolute positioned for flyout effect
		var hContent = "<div style='position:absolute' class='-ac-content'>";
		hContent +=  Mustache.to_html( h, aData ) + "</div>";
		// write it into the list node
		a.dnList.innerHTML = hContent;
		// get this content DOM node
		var dnContent = a.dnList.firstChild;
		// and resize to the width of input field
		// __.dn.dx( dnContent, __.dn.dx( a.dn ) );
		dnContent.__dx( dnContent, a.dn.__dx( a.dn ) );
		// next we iterate through all row generated by mustache
		__.dn.each( dnContent.children, function( dn ) {
			// and add a class indicating its a row created
			// by this library, it is used later on
			dn.classList.add( "-ac-row" );
			// next we check if the content is found in the
			// list of inactive terms
			var sText = dn.textContent;
			if( a.lsInactive.indexOf( sText ) > -1 ) {
				// in which case we add according class
				dn.classList.add( "-ac-inactive" );
			}
		} );
		// in case we want to mess with the output before it is
		// shown to the users (e.g. deactivate already selected
		// tags) we can indicate on a callback which is invoked
		// now along with the output DOM node as parameter.
		if( a.render_ ) {
			a.render_( a.dnList );
		}
		// and show it
		a.dnList.__show();
	}
	, hCreate : function() {
		return '<div style="display:none;position:relative;" class="-ac-list"></div>';
	}
};


// REF: remove __.dn from here were possible, e.g. __.dn.css
// REF: include loading gif that only shows after 500 ms
if( typeof( __ ) == "undefined" ) {
	__ = {};
}

__css( '.-lck-bag {position : relative;display : none;}  .-lck-bag-back, .-lck-bag-front {position : absolute;width : 100%;height : 100%;left : 0;top : 0;z-index : 66666666666;}.-lck-bag-back {z-index : 55555555555;opacity : 0.6;background : #fff;}.-lck-bag-front{display : table;width : 100%;}.-lck-bag-front div.-lck-loading{font-size:1.4em;font-weight:bold;text-align : center;display: table-cell;vertical-align: middle; }' );


__.lock = {
	  up : function( dn, kv ) {
		// set timeout for we want to ensure this is run
		// after any other rendering is done and we get
		// proper CSS values
		setTimeout( function() {
			var dnBag = dn.lastElementChild;
			// DOM node is empty. In case of a model get call,
			// this means its the first call to the server
			if( ! dnBag ) {
				dnBag = document.createElement( "div" );
				dnBag.__css( "height", dn.__css( "minHeight" ) );
				dn.appendChild( dnBag );
			}
			// locking blend (bag) does not exist...
			if( ! dnBag.classList.contains( "-lck-bag" ) ) {
				var hBag = " \
				<div class='-lck-bag'> \
					<div class='-lck-bag-front'></div> \
					<div class='-lck-bag-back'></div> \
				</div> \
				";
				// ...we append and position bag to top by height
				// because if we prepend and have Hx tags then
				// because of top padding entire stone gets shifted down
				
				dnBag = dn.__append( hBag );
			}
			// adjust height of blend and show
			// dy needs to be the outer height with padding
			var dy = dn.scrollHeight;
			var dnFront = dnBag.firstElementChild;
			dnFront.innerHTML = "";
			if( kv && kv.hText ) {
				setTimeout( function() {
					dnFront.__h( kv.hText );
					dnFront.__y( -dy );
					dnFront.__dy( dy );
				}, 500 );
			}
			var dnBack = dnBag.lastElementChild;
			dnBack.__y( -dy );
			dnBack.__dy( dy );
			dnBack.__show();
			dnBag.__show();
		}, 0 );
	}
	, un : function( dn ) {
		// set timeout as a consequence of us using it for locking as well
		setTimeout( function() {
			dn.__find( ".-lck-bag", function( dnBag ) {
				dnBag.__remove();
			} );
		}, 0 );
	}
};

Mustache=function(){var a=function(){};a.prototype={otag:"{{",ctag:"}}",pragmas:{},buffer:[],pragmas_implemented:{"IMPLICIT-ITERATOR":true},context:{},render:function(e,d,c,f){if(!f){this.context=d;this.buffer=[]}if(!this.includes("",e)){if(f){return e}else{this.send(e);return}}e=this.render_pragmas(e);var b=this.render_section(e,d,c);if(f){return this.render_tags(b,d,c,f)}this.render_tags(b,d,c,f)},send:function(b){if(b!=""){this.buffer.push(b)}},render_pragmas:function(b){if(!this.includes("%",b)){return b}var d=this;var c=new RegExp(this.otag+"%([\\w-]+) ?([\\w]+=[\\w]+)?"+this.ctag);return b.replace(c,function(g,e,f){if(!d.pragmas_implemented[e]){throw ({message:"This implementation of mustache doesn't understand the '"+e+"' pragma"})}d.pragmas[e]={};if(f){var h=f.split("=");d.pragmas[e][h[0]]=h[1]}return""})},render_partial:function(b,d,c){b=this.trim(b);if(!c||c[b]===undefined){throw ({message:"unknown_partial '"+b+"'"})}if(typeof(d[b])!="object"){return this.render(c[b],d,c,true)}return this.render(c[b],d[b],c,true)},render_section:function(d,c,b){if(!this.includes("#",d)&&!this.includes("^",d)){return d}var f=this;var e=new RegExp(this.otag+"(\\^|\\#)\\s*(.+)\\s*"+this.ctag+"\n*([\\s\\S]+?)"+this.otag+"\\/\\s*\\2\\s*"+this.ctag+"\\s*","mg");return d.replace(e,function(h,i,g,j){var k=f.find(g,c);if(i=="^"){if(!k||f.is_array(k)&&k.length===0){return f.render(j,c,b,true)}else{return""}}else{if(i=="#"){if(f.is_array(k)){return f.map(k,function(l){return f.render(j,f.create_context(l),b,true)}).join("")}else{if(f.is_object(k)){return f.render(j,f.create_context(k),b,true)}else{if(typeof k==="function"){return k.call(c,j,function(l){return f.render(l,c,b,true)})}else{if(k){return f.render(j,c,b,true)}else{return""}}}}}}})},render_tags:function(k,b,d,f){var e=this;var j=function(){return new RegExp(e.otag+"(=|!|>|\\{|%)?([^\\/#\\^]+?)\\1?"+e.ctag+"+","g")};var g=j();var h=function(n,i,m){switch(i){case"!":return"";case"=":e.set_delimiters(m);g=j();return"";case">":return e.render_partial(m,b,d);case"{":return e.find(m,b);default:return e.escape(e.find(m,b))}};var l=k.split("\n");for(var c=0;c<l.length;c++){l[c]=l[c].replace(g,h,this);if(!f){this.send(l[c])}}if(f){return l.join("\n")}},set_delimiters:function(c){var b=c.split(" ");this.otag=this.escape_regex(b[0]);this.ctag=this.escape_regex(b[1])},escape_regex:function(c){if(!arguments.callee.sRE){var b=["/",".","*","+","?","|","(",")","[","]","{","}","\\"];arguments.callee.sRE=new RegExp("(\\"+b.join("|\\")+")","g")}return c.replace(arguments.callee.sRE,"\\$1")},find:function(c,d){c=this.trim(c);function b(f){return f===false||f===0||f}var e;if(b(d[c])){e=d[c]}else{if(b(this.context[c])){e=this.context[c]}}if(typeof e==="function"){return e.apply(d)}if(e!==undefined){return e}return""},includes:function(c,b){return b.indexOf(this.otag+c)!=-1},escape:function(b){b=String(b===null?"":b);return b.replace(/&(?!\w+;)|["<>\\]/g,function(c){switch(c){case"&":return"&amp;";case"\\":return"\\\\";case'"':return'"';case"<":return"&lt;";case">":return"&gt;";default:return c}})},create_context:function(c){if(this.is_object(c)){return c}else{var d=".";if(this.pragmas["IMPLICIT-ITERATOR"]){d=this.pragmas["IMPLICIT-ITERATOR"].iterator}var b={};b[d]=c;return b}},is_object:function(b){return b&&typeof b=="object"},is_array:function(b){return Object.prototype.toString.call(b)==="[object Array]"},trim:function(b){return b.replace(/^\s*|\s*$/g,"")},map:function(f,d){if(typeof f.map=="function"){return f.map(d)}else{var e=[];var b=f.length;for(var c=0;c<b;c++){e.push(d(f[c]))}return e}}};return({name:"mustache.js",version:"0.3.1-dev",to_html:function(d,b,c,f){var e=new a();if(f){e.send=f}e.render(d,b,c);if(!f){return e.buffer.join("\n")}}})}();
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @output_file_name __.sp.1.0.0.min.js
// @js_externs var __; __.SP; __.SP.ctx
// ==/ClosureCompiler==

/**
 * @version 1.0.0
 * @namespace __
 */
if( typeof __ == "undefined" ) {
	__ = {};
}

/**
 * @namespace __.SP
 * @memberof __
 */


__.SP = {
	/**
	 * Gets a SharePoint context of the current site or a site you
	 * indicate via absolute Url
	 * @memberof __.SP
	 * @method ctx
	 * @example var ctx = __.SP.ctx();
	 * @example var ctx = __.SP.ctx( "https://jarvis.osce.org/sites/sec_ict" );
	 * @param {String} [sSite] Absolute Url of the SharePoint site
	 * @returns {Object} SharePoint site context
	 */
	  ctx : function( args ) {
		return ( args && args.sSite )
			? new SP.ClientContext( args.sSite )
			: new SP.ClientContext.get_current();
	}
	/**
	 * Executes an asynchronous call against the server.
	 * <br />
	 * It expects a SharePoint object to be loaded. Optionally you can indicate
	 * a callback function that will be invoked by the returned object or 
	 * an error message and stack in case of failure.
	 * @memberof __.SP
	 * @method exec
	 * @example __.SP.exec( ctx, oItem, function( oItem ) {
	 * 	if( oItem.sError ) {
	 * 		// error case
	 *		// oItem.sError holds the error message
	 * 		// oItem.sInfo holds the error stack
	 *	}
	 * 	else {
	 * 		// success case
	 * 	}
	 * } );
	 * @param {Object} ctx SharePoint site context
	 * @param {Object} oLoad Loaded object to be sent to server
	 * @param {Function} cb Callback function that handles success and error
	 */
	, exec : function( ctx, oLoad, cb ) {
		var cbok = function() {
			if( cb ) {
				cb( oLoad );
			}
		}
		var cberr = function( sender, args ) {
			if( cb ) {
				cb( {
					  sError : args.get_message()
					, sInfo: args.get_stackTrace()
				} );
			}
		}
		ctx.executeQueryAsync(
			  Function.createDelegate( this, cbok )
			, Function.createDelegate( this, cberr )
		);
	}
	/**
	 * Checks if a value is of form of a GUID
	 * @memberof __.SP
	 * @method bGuid 
	 * @example __.SP.bGuid( "12345678-asdf-zxcv-qwwe-1234567890ab" ) // true
	 * @example __.SP.bGuid( "567890ab" ) // false
	 * @example __.SP.bGuid( 321 ) // false
	 * @param {String} guid value of a guid
	 * @returns {Boolean} true or false
	 */
	, bGuid : function( x ) {
		return /^\w{8}-\w{4}-\w{4}-\w{4}-\w{12}$/.test( x );
	}
};

__.SP.deploy = {
	  list : function( args ) {
		var sList = args.oDeploy.sList;
		var sType = args.oDeploy.sType;
		var aSettings = args.oDeploy.aSettings || {};
		var loFields = args.oDeploy.loFields;
		var lsFields = [];
		loFields.forEach( function( oField ) {
			lsFields.push( oField.sName );
		} );
		var async = __.Async.promise( args )
		async
		.debug()
		.then( __.SP.list, "exists", { sList : sList } )
		.then( function( args ) {
			var async = __.Async.promise( args );
			var bCreate = true;
			if( args.bExists ) {
				if( args.bPurge ) {
					async.then( __.SP.list, "del" );
				}
				else {
					bCreate = false;
				}
			}
			if( bCreate ) {
				async.then( __.SP.list, "create", { sType : sType }, "create list " + sList )
				async.then( __.SP.list, "setColumns", { sList : sList, loFields : loFields}, "set columns in list " + sList )
				async.then( __.SP.list, "addFields", { sList : sList, loFields : loFields }, "add fields to list " + sList )
				async.then( __.SP.list, "setLookups", {}, "setup lookups in list " + sList )
			}
			async.resolve();
		} )
		.then( __.SP.list, "settings", { kvFeatures : aSettings }, "apply settings to list " + sList )
		.then( function( args ) {
			var async = __.Async.promise( args );
			for( var sFile in args.oDeploy.jsLinks ) {
				var jsLink = args.oDeploy.jsLinks[ sFile ];
				if( ! /\.aspx/.test( sFile ) ) {
					async.then( __.SP.list.field, "setJsLink", {
						  sList : sList
						, sField : "jsLink"
						, urlJsLink : jsLink
					}, "set jslink on field" )
				}
			}
			async.resolve();
		}, "set js links on views" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			for( var sView in args.oDeploy.aViews ) {
				var aView = args.oDeploy.aViews[ sView ];
				var bDefaultView = ( args.oDeploy.sDefaultView && sView == args.oDeploy.sDefaultView ) ? true : null;
				async.then( __.SP.view, "add", {
					  sList : sList
					, bDefaultView : bDefaultView
					, bPublic : true
					, sView : sView
					, lsFields : aView.lsFields
					, xmlQuery : aView.xmlQuery
				}, "create " + sView )
			}
			async.resolve();
		}, sList + " - create views" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			for( var sFile in args.oDeploy.jsLinks ) {
				var jsLink = args.oDeploy.jsLinks[ sFile ];
				if( /\.aspx/.test( sFile ) ) {
					var path = ( sType == "documentLibrary" )
						? sList + "/Forms/" + sFile
						: "/Lists/" + sList + "/" + sFile;
					async.then( __.SP.webpart, "settings", {
						  path : path
						, kv : {
							JSLink : jsLink
						}
					}, "set jslink on view: " + sFile )
				}
			}
			async.resolve();
		}, sList + " - set js links in webpart" )
		async.then( __.SP.list.field, "reorder", { sList : sList, lsFields : lsFields }, sList + " - reorder fields" )
		.then( __.SP.list.field, "displays", { loFields : loFields }, sList + " - set field displays" )
		.then( function( args ) {
			__.Async.promise( args ).resolve();
		}, "finished deploying: " + sList )
		.resolve();
	}
}

__.SP.sprvPage = null;
__.SP.scurPage = null;

if( self == top ) {
	__.SP.scurPage = null;
	window.addEventListener( "hashchange", function() {
		var url = unescape( unescape( self.location.href ) );
		__.SP.sprvPage = __.SP.scurPage || "";
		__.SP.scurPage = url;
		// check if a list is loaded
		var ls = url.match( /\/Lists\/(.*?)\// );
		var sList = "";
		if( ls && ls.length ) {
			sList = ls[ 1 ];
		}
		var ls = url.match(  /#.*\/(.*?)\.aspx/ );
		// get the current page
		var sPage = "";
		if( ls && ls.length ) {
			sPage = ls[ 1 ];
		}
		__.Event.trigger( "hashchange", {
			  sList : sList
			, sPage : sPage
			, sprvPage : __.SP.sprvPage
			, scurPage : __.SP.scurPage
		} );

		// empty #Dossier on hashchange since MDS-SP unloads external CSS at this
		// event rendering the form (content of #Dossier) unreadable so we set
		// inline styles on #Dossier and empty content on hashchange
		/*
		var dn = __.dn_( "#dossier-title" );
		if( dn ) {
			__.dn.del( dn );
		}
		var dn = __.dn_( "#Dossier" );
		if( dn ) {
			dn.innerHTML = "";
		}
		*/
	} );
}

/* tyepf def of caml field, expected format: 
 * {
 *   Country : { sType : "Lookup", v: [ [2, 6] ] } // 2dim array for ORing multiple. NB: inner array holds term id plus children
 * , Published : { sType : "Boolean", v: 1 }
 * , FrontOffice : { sType : "Text", v: "OSG" }
 * }
 */
/**
 * @namespace __.SP.caml
 * @memberof __.SP
 */
__.SP.caml = {};

/**
 * <pre>
 * Analyzes the URL and extracts the current query applied to a list.
 * </pre>
 * @memberof __.SP.caml
 * @method analyzeUrl
 * @todo typedef caml object
 * @example
 * __.SP.caml.analyzeUrl();
 * @returns {Object} aCAMLFields JSON describing the current query
 */
__.SP.caml.analyzeUrl = function() {
	var url = unescape( unescape( ( self.location.href ) ) );
	var sQuery;
	if( /ServerFilter=/.test( url ) ) {
		sQuery = "?" + url.split( "ServerFilter=" )[ 1 ];
		sQuery = sQuery.replace( /-/g, "&" );
	}
	else if( /FilterField1/.test( url ) ) {
		sQuery = url;
	}
	else {
		return null;
	}
	var oParams = __.url.oParams( sQuery );
	var aCAMLFields = {};
	for( var kParam in oParams ) {
		var ls = kParam.match( /FilterField(.*)$/ );
		if( ls ) {
			var k = oParams[ kParam ];
			var ix = ls[ 1 ];
			var v =  oParams[ "FilterValue" + ix ]
			aCAMLFields[ k ] = {
				v : v, sType: "Text"
			};
			if( oParams[ "FilterLookupId" + ix ] ) {
				aCAMLFields[ k ].sType = "Lookup";
				aCAMLFields[ k ].v = v.split( "," );
			}
			else if( ! isNaN( v ) ) {
				v = Number( v );
				if( v == 1 || v == 0 ) {
					aCAMLFields[ k ].v = v;
					aCAMLFields[ k ].sType = "Boolean";
				}
			}
		}
	};
	return aCAMLFields;
}

/**
 * <pre>
 * Creates fields of a CAML query reading from an array of {oField} objects
 * </pre>
 * @memberof __.SP.caml
 * @method createFields
 * @todo typedef caml object
 * @example
 * __.SP.caml.createFields( { loFields : loFields } );
 * @param {oField} loFields an array of list field objects "oField"
 * @returns {String} lxml array of xml string representing CAML query fields
 */
__.SP.caml.createFields = function( loFields ) {
	var lxml = [];
	loFields.forEach( function( aField ) {
		var sField = aField.sName;
		switch( aField.sType ) {
			case "ListOfIDs" :
				var xml = "<In>";
				xml += '<FieldRef Name="'+ sField + '" />';
				xml += "<Values>";
				aField.v.forEach( function( n ) {
					xml += '<Value Type="Number">' + n + '</Value>';
				} );
				xml += "</Values>";
				xml += "</In>";
				console.log( xml );
			break;
			case "taxonomy" :
				var xml = "";
				var lxmlIn = [];
				aField.v.forEach( function( laTaxFields ) {
					var xmlIn = "<In>";
					xmlIn += '<FieldRef LookupId="True" Name="'+ sField + '" />';
					xmlIn += "<Values>";
					laTaxFields.forEach( function( aTaxField ) {
						var id = aTaxField.id;
						var sName = escape( aTaxField.sName );
						// in case we have an ID == -1 this means the term had not yet been
						// assigned to any item however we need to put an ID (that won't return
						// results) for otherwise it'll impose no restrictions.
						var sTermNotAssignedYet = ( id == -1 )
							? ' sTermNotAssignedYet="' + sName + '"' : '';
						xmlIn += '<Value ' + sTermNotAssignedYet + ' Type="Integer">' + id + '</Value>';
					} );
					xmlIn += "</Values>";
					xmlIn += "</In>";
					lxmlIn.push( xmlIn );
				} );
				xml += __.SP.caml.wrap( lxmlIn, "Or" );
			break;
			case "boolean" :
				var xml = "<Eq>";
				xml += '<FieldRef Name="' + sField + '" />';
				xml += '<Value Type="Integer">' + aField.v + '</Value>';
				xml += "</Eq>";
			break;
			case "text" :
			case "choice" :
				var xml = "<" + aField.sOperator + ">";
				xml += '<FieldRef Name="' + sField + '" />';
				xml += '<Value Type="Text">' + aField.v + '</Value>';
				xml += "</" + aField.sOperator + ">";
			break;
			case "lookup" :
				var xml = "<" + aField.sOperator + ">";
				xml += '<FieldRef Name="' + sField + '" />';
				xml += '<Value Type="Lookup">' + aField.v + '</Value>';
				xml += "</" + aField.sOperator + ">";
			break;
			// REF: date, people missing
		}
		lxml.push( xml );
	} );
	return lxml;
};

/**
 * <pre>
 * Reads array of xml string representing CAML query fields and wraps them in 
 * logical operator tags nesting them properly.
 * </pre>
 * @memberof __.SP.caml
 * @method wrap 
 * @example
 * __.SP.caml.wrap( {
 *       lxml : [
 *          "<Eq><FieldRef Name='ID' /><Value Type='Integer'>1</Value></Eq>" 
 *        , "<Eq><FieldRef Name='ID' /><Value Type='Integer'>9</Value></Eq>"
 *     , sOpr : "And"
 * } );
 * @param {Array} lxml array of xml string representing CAML query fields
 * @param {String} sOpr logical operator
 * @returns {String} xml xml string representing CAML fields queries wrapped in logical operators
 */
__.SP.caml.wrap = function( lxml, sOpr ) {
	var nl = "\n";
	var sOpr = sOpr || "And";
	var wrap = function( sContent ) {
		return "<" + sOpr + ">" + nl + sContent + "</" + sOpr + ">" + nl;
	}
	var xml = "";
	// safety clause for while
	var x = 100;
	if( lxml.length == 1 ) {
		xml = lxml[ 0 ];
	}
	else if( lxml.length > 1 ) {
		xml += lxml.pop() + nl;
		xml += lxml.pop() + nl;
		xml = wrap( xml );
		while( lxml.length && (--x>0) ) {
			if( lxml.length > 0 ) {
				xml = wrap( lxml.pop() + nl + xml );
			}
		}
	}
	return xml;

};

/**
 * <pre>
 * Takes string representing CAML fields queries and a logical operators
 * and wraps it in <where> clause returning it as CAML query
 * </pre>
 * @memberof __.SP.caml
 * @method whereClause
 * @example
 * __.SP.caml.whereClaue( {
 *       lxml : [
 *          "<Eq><FieldRef Name='ID' /><Value Type='Integer'>1</Value></Eq>" 
 *        , "<Eq><FieldRef Name='ID' /><Value Type='Integer'>9</Value></Eq>"
 *     , sOpr : "And"
 * } );
 * @param {Array} lxml array of xml string representing CAML query fields
 * @param {String} [sOpr] logical operator defaults to "And"
 * @returns {String} xml xml string representing a CAML query
 */
__.SP.caml.whereClause = function( lxml, sOpr ) {
	var sOpr = sOpr || "And";
	return '<Where>' + this.wrap( lxml, sOpr ) + '</Where>';
}

/**
 * <pre>
 * Analyzes the URL and extracts the current query applied to a list and returns
 * it as xml string representing a CAML query.
 * </pre>
 * @memberof __.SP.caml
 * @method convertFromUrl
 * @example __.SP.caml.convertFromUrl();
 * @returns {String} xml xml string representing a CAML query
 */
__.SP.caml.convertFromUrl = function() {
	var oFields = __.SP.caml.analyzeUrl();
	if( oFields ) {
		var lxml = __.SP.caml.createFields( oFields );
		var sWhere = __.SP.caml.whereClause( lxml );
		var sSort = '<OrderBy><FieldRef Name="Title" /><FieldRef Name="FirstName" /></OrderBy>';
		return sSort + sWhere;
	}
	return null;
}
__.Async.fnerr = function( oError ) {
	top.__.SP.Error.show( oError );
};

top.__.SP.Error = __.Class.extend( {
	  dnWindow : null
	, oError : {}
	, createErrorData : function( args ) {
		var sError = "An incident happened";
		var sDescription = "";
		if( args.sdftError ) {
			sError = args.sdftError + "\r\n";
			if( args.sError ) {
				sDescription = args.sError;
			}
		}
		else if( args.sError ) {
			sError = args.sError;
			sDescription = "";
		}
		else if( typeof args == "string" ) {
			sError = args;
			sDescription = "";
		}
		// generate error code
		var sApplication = "SP";
		if( args.id ) {
			var lscurApplication = args.id.match( /^O\$C3\.(.*?)\./ );
			if( lscurApplication && lscurApplication[ 1 ] ) {
				sApplication = lscurApplication[ 1 ].toUpperCase();
			}
		}
		var idError = sApplication.toLowerCase() + "_" + Math.floor( (1 + Math.random() ) * 0x10000 ).toString( 16 );
		// check if we got an external error code passed
		// in wich case we take that one and remove it from error message
		var rxidError = new RegExp( /\[CODE\|(.*?)\]/ );
		var lsErrorId = sError.match( rxidError );
		if( lsErrorId && lsErrorId[ 1 ] ) {
			// get (external) error id
			idError = lsErrorId[ 1 ];
			// and remove from error string
			sError = sError.replace( rxidError, "" ).trim();
		}
		var now = new Date();
		var dt = new Date( now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(),  now.getUTCHours(), now.getUTCMinutes(), now.getUTCSeconds() );
		__.SP.user.current();
		var sUser = ( top.__.SP.user.aInfo && top.__.SP.user.aInfo.sLogin )
			? top.__.SP.user.aInfo.sLogin : "";
		this.oError = {
			  sTitle : args.sTitle || "System Message"
			, sError : sError
			, sDescription : sDescription
			, sUser : sUser
			, dt : dt
			, idError : idError
			, sApplication : sApplication
			, sInfo : args.sInfo || null
			, sStack : args.sStack || null
			, sLevel : args.sLevel || "ERROR"
			, sSite : _spPageContextInfo.siteServerRelativeUrl
			, url : self.location.href
		};
	}
	, log : function() {
		var sException = this.oError.__toString();
		if( ! sException ) {
			sException = "[fallback]" + this.oError.sError + this.oError.sStack + this.oError.url;
		}
		var oPayload = {
			  level : this.oError.sLevel
			, message : "[" + this.oError.idError + "][" + O$C3.sApp + "] " + this.oError.sError
			, exception : sException
		}
		top.__.SP.webservice.call( {
			  sService : "midtier"
			, sEndpoint : "Log4NetExternal"
			, oPayload : oPayload
			, bIgnoreFailure : true
		} );
	
	}
	, hMessage : function() {
		var hTemplate = " \
			<div class='osce-error'> \
				<p> \
					An unexpected error has occurred. The details have been logged. \
				</p> \
				<p> \
					Please close this dialog and try to repeat the operation. If the error continues, \
					contact IT Service Desk and include the details below in your report. \
				</p> \
				<div class='line'>&nbsp;</div> \
				<table class='osce-error'> \
					<tr> \
						<td class='title'>Timestamp (UTC):</td> \
						<td>{{dt}}</td> \
					</tr> \
					<tr> \
						<td class='title'>Username:</td> \
						<td>{{sUser}}</td> \
					</tr> \
					<tr> \
						<td class='title'>Error ID:</td> \
						<td>{{idError}}</td> \
					</tr> \
					<tr> \
						<td class='title'>Error message(s):</td> \
						<td class='message'> \
						<textarea disabled>{{sError}}{{sDescription}}</textarea> \
						</td> \
					</tr> \
				</table> \
			</div> \
		";
		try {
			return Mustache.to_html( hTemplate, this.oError );
		}
		catch( e ) {
			console.warn( "mustach error", e );
			return null;
		}
	}
	, init : function( args ) { 
		// the error below is triggered by SharePoint in case an internal Ajax request is cancelled,
		// e.g. by navigating away from a page before a result was delivered. We can savely ignore.
		if( args && args.sError && /The status code of response is '0'./.test( args.sError ) ) {
			console.warn( "ajax navigation abort hickup" );
			return;
		}
		console.warn( "-------------ERROR-------------" );
		console.warn( args );
		console.warn( "-------------ERROR-------------" );
		var that = this;
		this.createErrorData( args );
		var hMessage = this.hMessage( this.oError );
		if( hMessage ) {
			var oApp = null;
			var bShowReportErrorButton = false;
			var sApp = "";
			if( O$C3 && O$C3[ this.oError.sApplication ] ) {
				bShowReportErrorButton = O$C3[ this.oError.sApplication ].bShowReportErrorButton;
				sApp = "[" + O$C3[ this.oError.sApplication ].sApp + "] ";
			}
			var oModalConfig = {
				  sTitle : that.oError.sTitle
				, hContent : hMessage
				, sOk : null
				, fnClose : function() {
					that.dnWindow.close();
					//that.closeAll();
				}
				, fnact : function() {
					var sBody = "Dear Service Desk,\r\n\r\n";
					if( sApp ) {
						sBody += "The application " + sApp + "showed ";
					}
					else {
						sBody += "An application showed ";
					}
					sBody += "the following error message:\r\n";
					sBody += "(" + that.oError.idError + ") " + that.oError.sError + "\r\n";
					sBody += " The error happend at this URL:\r\n";
					sBody += that.oError.url + "\r\n\r\n\r\n";
					sBody += "\tBest regards,";
					var url = "mailto:ICTServicedesk@osce.org";
					var url = "mailto:jriemer@osce.org";
					url += "?subject=" + sApp + that.oError.sError;
					url += "&body=" + encodeURIComponent( sBody );
					window.location.href = url;
					that.dnWindow.close();
				}
			};
			if( O$C3 && O$C3[ this.oError.sApplication ] ) {
				if( O$C3[ this.oError.sApplication ].bShowReportErrorButton ) {
					oModalConfig.sOk = "Report";
				}
			}
			this.dnWindow = top.__.SP.modal.open( oModalConfig );
		}
		this.log();
	}
} );

top.__.SP.Error.show = function( args ) {
	return __.Class.instantiate( top.__.SP.Error, args );
};

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.view; __.SP.read; __.SP.deleteFields; __.SP.add; __.SP.del; __.SP.update; __.SP.copy;
// ==/ClosureCompiler==


/**
 * Methods that deal with SharePoint list views
 * @namespace __.SP.view
 * @memberof __.SP
 */

__.SP.view = {};

/**
 * Get all views of a list.
 * @memberof __.SP.view
 * @method list
 * @instance
 * @async
 * @example
 * __.SP.view.list( {
 *     sList : "OSCE Contacts"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * lsViews | (Array) | array of view names
 * </pre>
 */
__.SP.view.list = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oViews = oList.get_views();
	ctx.load( oViews );
	__.SP.exec( ctx, oViews, function( oViews ) {
		if( oViews.sError ) {
			async.reject( oViews.sError );
		}
		else {
			var lsViews = [];
			var loView = oViews.getEnumerator();
			while( loView.moveNext() ) {
				var oView = loView.get_current();
				lsViews.push( oView.get_title() );
			}
			async.resolve( { lsViews : lsViews } );
		}
	} );
}

/**
 * Get information on a particular view.
 * @memberof __.SP.view
 * @method read
 * @instance
 * @async
 * @example
 * __.SP.view.read( {
 *       sList : "OSCE Contacts"
 *     , sView : "All items"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sView name of the view
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * kv | (Object) | key/value pair of properties
 * kv.guid | (String) | guid of the view
 * kv.lsFields | (Array) | array of fields shown in the view
 * kv.urlJSLink | (String) | url to the jsLink file
 * kv.nRows | (Number) | number of rows displayed
 * kv.bPaging | (String) | flag indicating whether the view has pagination
 * kv.sTotal | (String) | name of field for which totals are generated (NB: only one, the first field is returned ATM)
 * kv.xmlQuery | (String) | CAML Query of the view
 * </pre>
 */
__.SP.view.read = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oView = oList.get_views().getByTitle( args.sView );
	var oFields = oView.get_viewFields();
	ctx.load( oView );
	ctx.load( oFields );
	__.SP.exec( ctx, oView, function( oView ) {
		if( oView.sError ) {
			async.reject( oView.sError );
		}
		else {
			var lsFields = [];
			var oFields = oView.get_viewFields();
			for( var ix=0; ix<oFields.get_count(); ix++ ) {
				var sField = oFields.getItemAtIndex( ix );
				lsFields.push( sField );
			}
			var sTotal = null;
			if( oView.get_aggregationsStatus() == "On" ) {
				var sAggregations = oView.get_aggregations();
				var lsParts = sAggregations.match( /Name="(.+?)"/ );
				if( lsParts && lsParts[ 1 ] ) {
					sTotal = lsParts[ 1 ];
				}
			}
			var kv = {
				  guid : oView.get_id().toString()
				, lsFields : lsFields
				, urlJSLink : oView.get_jsLink()
				, nRows : oView.get_rowLimit()
				, bPaging : oView.get_paged()
				, sTotal : sTotal
				, xmlQuery : oView.get_viewQuery()
			};
			async.resolve( { kv : kv } );
		}
	} );
}

/**
 * Deletes fields displayed in a view
 * @memberof __.SP.view
 * @method deleteFields
 * @instance
 * @async
 * @example
 * __.SP.view.deleteFields( {
 *       sList : "OSCE Contacts"
 *     , sView : "All items"
 *     , lsFields : [ "Title", "ID" ]
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sView name of the view
 * @param {Array} args.lsFields array of field names to be removed from the view's display
 */
__.SP.view.deleteFields = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oView = oList.get_views().getByTitle( args.sView );
	var oFields = oView.get_viewFields();
	ctx.load( oView );
	ctx.load( oFields );
	__.SP.exec( ctx, [ oView, oFields ], function( lo ) {
		var oView = lo[ 0 ];
		var oFields = lo[ 1 ];
		if( lo.sError ) {
			async.reject( lo.sError );
		}
		else {
			for( var ix=0; ix<oFields.get_count(); ix++ ) {
				var sField = oFields.getItemAtIndex( ix );
				var b = args.lsFields.__contains( sField );
				if( b ) {
					oFields.remove( sField );
				}
			}
			oView.update();
			__.SP.exec( ctx, oView, function( o ) {
				if( o.sError ) {
					async.reject( o.sError );
				}
				else {
					async.resolve();
				}
			} );
		}
	} );
}
// __.SP.view.add( { sList:"OSCE Contacts",sView:"test_me",lsFields:["Title","Country","Company"],xmlQuery:'<OrderBy><FieldRef Name="Title" /></OrderBy><Where><Eq><FieldRef Name="FrontOffice" /><Value Type="Text">OCEEA</Value></Eq></Where>'} );
/**
 * Adds a new view to a list
 * @memberof __.SP.view
 * @instance
 * @async
 * @method add
 * @example
 * __.SP.view.deleteFields( {
 *       sList : "OSCE Contacts"
 *     , sView : "All items"
 *     , lsFields : [ "Title", "ID" ]
 *     , xmlQuery : '<OrderBy><FieldRef Name="Title" /></OrderBy><Where><Eq><FieldRef Name="Title" /><Value Type="Text">Hi Mom</Value></Eq></Where>'
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sView name of the view
 * @param {Array} args.lsFields array of field names to be displayed in the view
 * @param {String} [args.sTotal] field name for which totals should be displayed (NB: ATM only one field is supported)
 * @param {String} [args.jsLink] URL of a JSLink file to be loaded with this view.
 * @param {Boolean} [args.bPublic] flag whether the view is public or personal (default is false/personal)
 * @param {Boolean} [args.bDefaultView] flag whether the view is set to be default (default is false)
 * @param {Number} [args.nRows] number of items to be shown on one page (default is 10)
 * @param {Boolean} [args.bPaging] flag whether the view shows pagination (default is false)
 */
__.SP.view.add = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oViews = oList.get_views();
	// REF: refactor bPersonal.. its confusing
	var bPersonal = ( args.bPublic ) ? false : true;
	ctx.load( oViews );
	__.SP.exec( ctx, oViews, function( oViews ) {
		if( oViews.sError ) {
			async.reject( oViews.sError );
		}
		else {
			var oView = new SP.ViewCreationInformation();
			oView.set_title( args.sView );
			oView.set_personalView( bPersonal );
			var oQuery = new SP.CamlQuery();
			oQuery.set_viewXml( args.xmlQuery );
			oView.set_query( oQuery );
			if( args.bDefaultView ) {
				oView.set_setAsDefaultView( true );
			}
			if( args.lsFields ) {
				oView.set_viewFields( args.lsFields );
			}
			if( args.nRows ) {
				oView.set_rowLimit( args.nRows );
			}
			if( args.bPaging ) {
				oView.set_paged( true );
			}
			oViews.add( oView );
			ctx.load( oViews );
			__.SP.exec( ctx, oViews, function( oViews ) {
				if( oViews.sError ) {
					async.reject( oViews.sError );
				}
				else {
					// since we cannot add jsLink on creation (sic!) we
					// need to update after creation
					if( args.jsLink ) {
						var oView = oList.get_views().getByTitle( args.sView );
						oView.set_jsLink( args.jsLink );
						oView.update();
						ctx.load( oView );
						__.SP.exec( ctx, oView, function( oView ) {
							if( oView.sError ) {
								async.reject( oView.sError );
							}
							else {
								if( args.sTotal ) {
									var xmlAggregation = '<FieldRef Name="' + args.sTotal + '" Type="COUNT" />';
									oView.set_aggregations( xmlAggregation );
									oView.set_aggregationsStatus( "On" );
									oView.update();
									ctx.load( oView );
									__.SP.exec( ctx, oView, function( oView ) {
										if( oView.sError ) {
											async.reject( oView.sError );
										}
										else {
											async.resolve();
										}
									} );
								}
								else {
									async.resolve();
								}
							}
						} );
					}
					// otherwise we resolve
					else {
						async.resolve();
					}
				}
			} );
		}
	} );
};

/**
 * Deletes a view from a list
 * @memberof __.SP.view
 * @method del
 * @instance
 * @async
 * @todo rename to remove
 * @example
 * __.SP.view.del( {
 *       sList : "OSCE Contacts"
 *     , sView : "All Items"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sView name of the view
 */
__.SP.view.del = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oView = oList.get_views().getByTitle( args.sView );
	oView.deleteObject();
	ctx.load( oView );
	__.SP.exec( ctx, oView, function( oView ) {
		if( oView.sError ) {
			// REF: below error message is thrown eventhough all is deleted.. don't know why
			if( /^Cannot complete this action/.test( oView.sError ) ) {
				async.resolve();
			}
			else {
				async.reject( oView.sError );
			}
		}
		else {
			async.resolve();
		}
	} );
};

/**
 * Updates properties of a view
 * @memberof __.SP.view
 * @method update
 * @instance
 * @async
 * @example
 * __.SP.view.update( {
 *       sList : "OSCE Contacts"
 *     , sView : "All Items"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sView name of the view
 * @param {String} [args.xmlQuery] CAML of the view
 * @param {String} [args.jsLink] Url of a JS Link file
 * @param {Number} [args.nRows] number of items shown in one result page
 * @param {String} [args.sTotal] name of field that should be counted
 * @param {Array} [args.lsFields] array of fields that should be displayed
 */
__.SP.view.update = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oView = oList.get_views().getByTitle( args.sView );
	var oFields = oView.get_viewFields();
	if( args.xmlQuery ) {
		var oQuery = new SP.CamlQuery();
		oQuery.set_viewXml( args.xmlQuery );
		oView.set_viewQuery( oQuery );
	}
	if( args.jsLink ) {
		oView.set_jsLink( args.jsLink );
	}
	if( args.nRows ) {
		oView.set_rowLimit( args.nRows );
	}
	if( args.sTotal ) {
		var xmlAggregation = '<FieldRef Name="' + args.sTotal + '" Type="COUNT" />';
		oView.set_aggregations( xmlAggregation );
		oView.set_aggregationsStatus( "On" );
	}
	oView.update();
	ctx.load( oView );
	ctx.load( oFields );
	__.SP.exec( ctx, oView, function( oView ) {
		if( oView.sError ) {
			async.reject( oView.sError );
		}
		else {
			if( args.lsFields ) {
				var loField = oFields.getEnumerator();
				var lsRemoveFields = [];
				while( loField.moveNext() ) {
					var sField = loField.get_current();
					lsRemoveFields.push( sField );
				}
				lsRemoveFields.forEach( function( s ) {
					oFields.remove( s );
				} );
				args.lsFields.forEach( function( s ) {
					oFields.add( s );
				} );
				oView.update();
				ctx.load( oFields );
				__.SP.exec( ctx, oFields, function( oFields ) {
					if( oView.sError ) {
						async.reject( oFields.sError );
					}
					else {
						async.resolve();
					}
				} );
			}
			else {
				async.resolve();
			}
		}
	} );
}

/**
 * Copies an existing view under a new name
 * @memberof __.SP.view
 * @method copy
 * @instance
 * @async
 * @example
 * __.SP.view.update( {
 *       sList : "OSCE Contacts"
 *     , sOldView : "All Items"
 *     , sNewView : "All Items Two"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sOldView name of the existing view
 * @param {String} args.sNewView name of the new view
 */
__.SP.view.copy = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oView = oList.get_views().getByTitle( args.sOldView );
	ctx.load( oView );
	__.SP.exec( ctx, oView, function( oView ) {
		if( oView.sError ) {
			async.reject( oView.sError );
		}
		else {
			var guid = oView.get_id().toString();
			oList.saveAsNewView( guid, args.sNewView, true, args.sNewView + ".aspx");
			var oView = oList.get_views().getByTitle( args.sNewView );
			ctx.load( oView );
			__.SP.exec( ctx, oView, function( oView ) {
				if( oView.sError ) {
					async.reject( oView );
				}
				else {
					async.resolve();
				}
			} );
		}
	} );
}

/**
 * @namespace __.SP.user
 * @memberof __.SP
 */

__.SP.user = {};

// Stores user info for consequtive calls to current()
__.SP.user.aInfo = {
	  id : -1
	, sLogin : "na"
	, mail : "na"
	, bAdmin : false
	, lsGroups : []
	, bLoaded : false
};

/**
 * Gets information on the currently logged in user
 * @memberof __.SP.user
 * @method current
 * @instance
 * @async
 * @example
 * __.SP.user.current();
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * aUserInfo | (Object) | key/value pair of properties
 * kv.id | (String) | id of the user
 * kv.sLogin | (Array) | domain/login of the user
 * kv.mail | (String) | email of the user
 * kv.bAdmin | (Number) | number of rows displayed
 * </pre>
 */
__.SP.user.current = function( args ) {
	var that = this;
	var async = __.Async.promise( args );
	if( this.aInfo.bLoaded ) {
		async.resolve( { aUserInfo : this.aInfo } );
		return;
	}
	var _getCurrentUserInfo = function() {
		var ctx = __.SP.ctx();
		var oUser = ctx.get_web().get_currentUser();
		ctx.load( oUser );
		__.SP.exec( ctx, oUser, function( oUser ) {
			if( oUser.sError ) {
				async.resolve( "Could not load user info", oUser );
			}
			else {
				that.aInfo = {
					  id : oUser.get_id()
					, sLogin : oUser.get_loginName()
					, mail : oUser.get_email()
					, bAdmin : oUser.get_isSiteAdmin()
					, bLoaded : true
				}
				async.resolve( { aUserInfo : that.aInfo } );
			}
		} );
	}
	SP.SOD.executeFunc( 'SP.js', 'SP.ClientContext', function() {
		SP.SOD.executeFunc( 'userprofile', 'SP.UserProfiles.PeopleManager', function() {
			_getCurrentUserInfo();
		} )
	} )
};
// execute it right away for will need it in any case
_spBodyOnLoadFunctionNames.push( "__.SP.user.current" );

/**
 * @namespace __.SP.taxonomy
 * @memberof __.SP
 */


// NOTE: in order to test on-the-fly-loading of taxonomy.js use this direct call: __.SP.taxonomy.load( { sTermSet : __.SP.taxonomy.oStore.guidTermSet.Country, cb : function( a ) { console.log( a ) } } )
//
__.SP.taxonomy = {};
// holds loaded taxonomies
__.SP.taxonomy.aTerms = {};
// holds all used taxonomy terms
__.SP.taxonomy.oTermInfo = null;


__.SP.taxonomy.loadSPScripts = function( args ) {
	var async = __.Async.promise( args );
	var hdTimeout = setTimeout( function() {
		async.reject( "Could not load taxonomy session from SharePoint" );
	}, 10000 );
	SP.SOD.executeFunc('SP.js', 'SP.ClientContext', function() {
		SP.SOD.registerSod('sp.taxonomy.js', SP.Utilities.Utility.getLayoutsPageUrl('sp.taxonomy.js'));
		SP.SOD.executeFunc( 'sp.taxonomy.js', 'SP.Taxonomy.TaxonomySession', function() {
			clearTimeout( hdTimeout );
			setTimeout( function() {
				async.resolve();
			}, 666 );
		} )
	} )
};




/**
 * Sets a taxonomy term in an add or edit form.
 * @memberof __.SP.taxonomy
 * @method setTermInForm
 * @instance
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sField name of the list's field
 * @param {String} args.sTerm name of the taxonomy term
 * @param {String} args.guid guid of the taxonomy term
 * @example __.SP.taxonomy.setTermInForm( {
 *	  sField : "Country"
 *	, sTerm : "Albania"
 *	, guid : "40690fe5-fd6d-4c27-bb52-b0d60a9e7d78"
 * } );
 */
__.SP.taxonomy.setTermInForm = function( args ) {
	var h;
	if( args.guid ) {
		var v = args.sTerm + "|" + args.guid;
		document.body.__find( "#" + args.sField + "_\\$input" ).value = v;
		h = "<span class='valid-text'>" + args.sTerm + "</span>";
	}
	else {
		h  = '<span class="invalid-text" ';
		h += 'title="The term is not a valid term">' + args.sTerm + '</span>';
	}
	document.body.__find( "#" + args.sField + "_\\$containereditableRegion" ).innerHTML = h;
	__.Async.promise( args ).resolve();
}


/**
 * Loads the hidden taxonomy term list for the current site with their site IDs, guid and names.<br>
 * It store them in a data object "__.SP.taxonomy.oTermInfo" using the internal ID as key.
 * @memberof __.SP.taxonomy
 * @method getTermIds
 * @async
 * @instance
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sField name of the list's field
 * @param {String} args.sTerm name of the taxonomy term
 * @param {String} args.guid guid of the taxonomy term
 * @example __.SP.taxonomy.getTermIds();
 */
__.SP.taxonomy.getTermIds = function( args ) {
	var async = __.Async.promise( args );
	// if we already loaded the term list we resolve
	if( __.SP.taxonomy.oTermInfo ) {
		async.resolve();
		return;
	}
	// otherwise we read the term list
	async.then( __.SP.list, "read", {
		  sList : "TaxonomyHiddenList"
		, lsFields : [ "IdForTerm", "ID", "Title" ]
	}, "Read taxonomy term id list" )
	async.then( function( args ) {
		__.SP.taxonomy.oTermInfo = {};
		args.lkv.forEach( function( kv ) {
			__.SP.taxonomy.oTermInfo[ kv.ID ] = {
				  id : kv.ID
				, sName : kv.Title
				, guid : kv.IdForTerm
			};
		} );
		__.Async.promise( args ).resolve();
	}, "Extract term id data" )
	async.resolve();
}

/**
 * Reads term info from the site's hidden taxonomy list.
 * @memberof __.SP.taxonomy
 * @method termInfo
 * @instance
 * @param {Number|String} id_or_guid_or_name Either the ID, the guid or the name of a taxonomy term.
 * @example __.SP.taxonomy.termInfo( "40690fe5-fd6d-4c27-bb52-b0d60a9e7d78"
);
 * @returns {Object} data object of the term
 * <pre class='return-object'>
 * id | (Number) | internal ID of the term
 * guid | (String) | guid of the term
 * sName | (String) | name of the term
 * </pre>
 */
__.SP.taxonomy.termInfo = function( id_or_guid_or_name ) {
	// in case of index we return immediately for this is the
	// key of the term info object
	if( typeof id_or_guid_or_name == "number" ) {
		return __.SP.taxonomy.oTermInfo[ id_or_guid_or_name ] || null;
	}
	// now lets check if input is term name or its guid and
	// assign the proper key
	var k = ( __.SP.bGuid( id_or_guid_or_name ) ) ? "guid" : "sName";
	// then iterate through the term object and look for the
	// machting entry
	for( var id in __.SP.taxonomy.oTermInfo ) {
		var aTermInfo = __.SP.taxonomy.oTermInfo[ id ];
		if( aTermInfo[ k ] === id_or_guid_or_name ) {
			// and send back if found
			return aTermInfo;
		}
	}
	// otherwise we send back null
	return null;
}

/**
 * Loads an entire taxonomy and creates structures for easy lookup by name,
 * guid and labels (i.e. synonyms).<br>
 * It also creates a linked list for parent/children relationships.
 * It returns the lookup objects as well as stores them into the data 
 * object "__.SP.taxonomy.aTerms" for later reference
 * @memberof __.SP.taxonomy
 * @method load
 * @async
 * @instance
 * @todo rename sTermSet to guidTermset
 * @todo create object definition of lookup object
 * @example __.SP.taxonomy.load( {
 * 	sTermSet : "40690fe5-fd6d-4c27-bb52-b0d60a9e7d78"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sTermSet guid of the term set
 * @param {String} [args.sTermStore] name of term store (default is "Managed Metadata Service")
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * aTerms | (Object) | lookup table for term names
 * aGuids | (Object) | lookup table for term guids
 * aLabels | (Object) | lookup table for term labels
 * aChildren | (Object) | lookup table for parent/children relationship
 * </pre>
 */
__.SP.taxonomy.load = function( args ) {
	var async = __.Async.promise( args );
	// first check if we already loaded the taxonomy
	var oTerms = __.SP.taxonomy.aTerms[ args.sTermSet ];
	if( oTerms ) {
		async.resolve( { oTerms : oTerms } );
		return;
	}
	async.then( __.SP.taxonomy, "loadSPScripts" )
	async.then( function( args ) {
		var ctx = __.SP.ctx();
		var sTermStore = args.sTermStore || "Managed Metadata Service";
		var oTax = SP.Taxonomy.TaxonomySession.getTaxonomySession( ctx );
		var oStore = oTax.get_termStores().getByName( sTermStore );
		var oSet = oStore.getTermSet( args.sTermSet );
		var oTerms = oSet.getAllTerms();
		ctx.load( oTerms, 'Include(Parent,Id,Name)');
		__.SP.exec( ctx, oTerms, function( oTerms ) {
			if( oTerms.sError ) {
				async.reject( oTerms.sError );
			}
			else {
				var loTerms = oTerms.getEnumerator();
				var aTerms = {};
				var aGuids = {};
				var aLabels = {};
				var aChildren = {};
				var sLastTerm = "";
				while( loTerms.moveNext() ) {
					var oTerm = loTerms.get_current();
					var oParent = oTerm.get_parent();
					var sMain = oTerm.get_name();
					var sLastTerm = sMain;
					var guid = oTerm.get_id().toString();
					if( ! oParent.get_serverObjectIsNull() ) {
						idParent = oParent.get_id().toString();
						if( ! aChildren[ idParent ] ) {
							aChildren[ idParent ] = [];
						}
						aChildren[ idParent ].push( guid );
					}
					aTerms[ sMain ] = {
						  guid : guid
						, lsLabels : []
					};
					aGuids[ guid ] = sMain;
					var oLabels = oTerm.getAllLabels( 1033 );
					ctx.load( oLabels );
					__.SP.exec( ctx, oLabels, function( oLabels, sMain ) {
						var loLabels = oLabels.getEnumerator();
						var sTerm = "";
						var vLookup = {};
						while( loLabels.moveNext() ) {
							var oLabel = loLabels.get_current();
							var sLabel = oLabel.get_value();
							if( aTerms[ sLabel ] ) {
								sTerm = sLabel;
								vLookup = {
									  sTerm : sTerm
									, guid : aTerms[ sTerm ].guid
								};
								aLabels[ sLabel ] = vLookup;
								aLabels[ sLabel.__tokenize() ] = vLookup;
							}
							else {
								aTerms[ sTerm ].lsLabels.push( sLabel );
								aLabels[ sLabel ] = vLookup;
								aLabels[ sLabel.__tokenize() ] = vLookup;
							}
						}
						if( ( sLastTerm == sTerm ) ) {
							var aResult = {
								  aTerms : aTerms
								, aGuids : aGuids
								, aLabels : aLabels
								, aChildren : aChildren
							}
							__.SP.taxonomy.aTerms[ args.sTermSet ] = aResult;
							async.resolve( { oTerms : aResult } );
						}
					} );
					// add the otherway around
				}
			}
		} );
	} );
	async.resolve();
};

/**
 * Retrieves all children term guids for a given parent term of a term set.
 * NB: The taxonomy needs to be loaded beforehand.
 * @memberof __.SP.taxonomy
 * @method children
 * @instance
 * @todo rename idTermSet and idParent to guidTermset and guidParent
 * @example __.SP.taxonomy.children( {
 * 	  idTermSet : "40690fe5-fd6d-4c27-bb52-b0d60a9e7d78"
 * 	, idParent : "13a5103e-ee20-44ce-a164-35943e9df08e"
 * } );
 * @param {String} idTermSet guid of the term set
 * @param {String} idParent guid of the parent term
 * @returns {Array} array of guids of all children terms
 */
__.SP.taxonomy.children = function( args ) {
	var oStore = __.SP.taxonomy.aTerms[ args.idTermSet ];
	var l = [];
	var add = function( id ) {
		if( id != args.idParent ) {
			l.push( id );
		}
		var lid = oStore.aChildren[ id ];
		if( lid ) {
			lid.forEach( function( id ) {
				add( id );
			} );
		}
		return l;
	}
	var lid = add( args.idParent );
	return lid;
};

/**
 * Adds a term to a term set.
 * <br>NB: it only adds them on the first level (only root nodes).
 * @memberof __.SP.taxonomy
 * @method addTerm
 * @async
 * @instance
 * @todo rename sTermSet to guidTermset
 * @example __.SP.taxonomy.addTerm( {
 * 	  lsTerms : [ "Neverland", "Oz" ]
 * 	, sTermSet : "40690fe5-fd6d-4c27-bb52-b0d60a9e7d78"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.lsTerms Array of the terms to be added.
 * @param {String} args.sTermSet guid of the term set
 */
__.SP.taxonomy.addTerm = function( args ) {
	var async = __.Async.promise( args );
	async.then( __.SP.taxonomy, "loadSPScripts" )
	async.then( function( args ) {
		var ctx = __.SP.ctx();
		var sTermStore = args.sTermStore || "Managed Metadata Service";
		var oTax = SP.Taxonomy.TaxonomySession.getTaxonomySession( ctx );
		var oStore = oTax.get_termStores().getByName( sTermStore );
		var oSet = oStore.getTermSet( args.sTermSet );
		args.lsTerms.forEach( function( sTerm ) {
			oSet.createTerm( sTerm, 1033, SP.Guid.newGuid().toString() );
		} );
		ctx.load( oSet );
		__.SP.exec( ctx, oSet, function( oSet ) {
			if( oSet.sError ) {
				async.reject( oSet.sError );
			}
			else {
				async.resolve();
			}
		} );
	} );
	async.resolve();
}

/* DEV */
__.SP.taxonomy.oStore = {
	  sTermStore : "Managed Metadata Service"
	, guidTermStore : "8d02b4f0e6264e2aa6002d5d65a8dfb3"
	, guidTermSet : {
		  Country : "e990b65b-82b3-4481-9463-802f636f8856"
		, AreaOfExpertise : "03b8827e-47a4-4ae3-922a-3d903ad677dc"
		, ExecutiveStructure : "ba5b00de-03f3-46f2-b220-33ae50ebe7f9"
		, InternationalOrganization : "f9f4527d-7bc3-4f7a-a720-aa5843dd919d"
		, ParticpatingStates : "f05295ce-64d8-44d9-8644-8e2f2eec2a5b"
		, PartnerStates : "44c548b9-92a9-4d0d-bda9-ac07b58bf80c"
		, MainCategory : "8f5c59e1-e30a-48a2-a2b4-fcaaf74f38f6"
		, CustomTags : "1485540c-abdd-4bcb-b0e7-87bd9191363d"
		, OCEEAEvents : "f6aba16a-8a3d-45d1-b470-a65033f6a7a7"
	}
};
/* TEST */
if( /^https:\/\/test-jarvis/.test( self.location.href ) ) {
	__.SP.taxonomy.oStore = {
		  sTermStore : "Managed Metadata Service"
		, guidTermStore : "c2caf26efa5d429a945ed57554249ca1"
		, guidTermSet : {
			  Country : "c87e11dd-026c-4334-921d-edec52527165"
			, AreaOfExpertise : "a49c339c-30e8-4144-954e-0c20b0f16ef9"
			, ExecutiveStructure : "4c09c31e-b9c9-4d93-83da-d50ca8eb9611"
			, InternationalOrganization : "d0893072-e0f8-4718-989f-f6a08210ff4f"
			, ParticpatingStates : "64d5c25b-8245-4a56-afd0-5c56db909777"
			, PartnerStates : "40d80d0e-7ef1-4ebc-af48-fe38450b9929"
			, MainCategory : "f9962d01-42b7-47f9-b092-9ea8e61653e4"
			, CustomTags : "a12b2608-e6f8-4f14-bf75-083d8b1d1691"
		}
	};
}
/* PROD */
if( /^https:\/\/jarvis/.test( self.location.href ) ) {
	__.SP.taxonomy.oStore = {
		  sTermStore : "Managed Metadata Service"
		, guidTermStore : "c5794c29a64a47ee98f7e64d4f1357cc"
		, guidTermSet : {
			  Country : "3743b356-9560-4283-974d-38269333882c"
			, AreaOfExpertise : "7b880df9-f193-4ce6-b64a-2d685ec39552"
			, ExecutiveStructure : "fb698d7a-4fd0-41fd-a193-f13b2f393e45"
			, InternationalOrganization : "30914819-db3e-45a0-9227-74dfa9c2779d"
			, ParticpatingStates : "afd94263-f917-4441-9754-81d2f6d7e165"
			, PartnerStates : "afd94263-f917-4441-9754-81d2f6d7e165"
			, MainCategory : "cf123dd7-6a4a-4343-b486-d1cc7262b930"
			, CustomTags : "a593da20-da70-47ff-901b-794043be996d"
		}
	};
}
/**
 * @namespace __.SP.site
 * @memberof __.SP
 */

__.SP.site = {};

/**
 * Get all groups from a site
 * @memberof __.SP.site
 * @method groups
 * @async 
 * @instance
 * @example
 * __.SP.site.groups( {
 * 	  sSite : "https://dev-sharepoint.osce.org/sites/pas"
 * 	, cb : function( a ) { console.log( a ) }
 * } )
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sSite url of the site
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * laLists | (Object) | list of group data objects 
 * </pre>
 */
__.SP.ctx = function( args ) {
		return ( args && args.sSite )
			? new SP.ClientContext( args.sSite )
			: new SP.ClientContext.get_current();
	}
__.SP.site.groups = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx( args );
	var oGroups = ctx.get_web().get_siteGroups();
	ctx.load( oGroups );
	__.SP.exec( ctx, oGroups, function( oGroups ) {
		if( oGroups.sError ) {
			async.reject( oGroups.sError );
		}
		else {
			var laGroups = [];
			var loGroups = oGroups.getEnumerator();
			while( loGroups.moveNext() ) {
				var oGroup = loGroups.get_current();
				var aGroup = {
					  id : oGroup.get_id()
					, sName : oGroup.get_title()
					, sType : oGroup.get_principalType()
					, sDescription : oGroup.get_description()
				};
				laGroups.push( aGroup );
			}
			async.resolve( { laGroups : laGroups } );
		}
	} );
}


/**
 * Get all lists from a site
 * @memberof __.SP.site
 * @method lists
 * @async 
 * @instance
 * @example
 * __.SP.site.lists( {
 * 	  sSite : "https://dev-sharepoint.osce.org/sites/pas"
 * 	, cb : function( a ) { console.log( a ) }
 * } )
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sSite url of the site
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * laLists | (Object) | list of list data objects 
 * </pre>
 */
__.SP.site.lists = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx( args );
	var oLists = ctx.get_web().get_lists();
	ctx.load( oLists, 'Include( Title,EntityTypeName,Hidden,BaseType,Description,BaseTemplate,ContentTypesEnabled,ContentTypes,Id )' );
	__.SP.exec( ctx, oLists, function( oLists ) {
		if( oLists.sError ) {
			async.reject( oLists.sError );
		}
		else {
			var laLists = [];
			var loLists = oLists.getEnumerator();
			while( loLists.moveNext() ) {
				var oList = loLists.get_current();
				// lookup content types
				var loCTs = oList.get_contentTypes().getEnumerator();
				var lsContentTypes = [];
				while( loCTs.moveNext() ) {
					var oCT = loCTs.get_current();
					lsContentTypes.push( oCT.get_name() );
				}
				var aList = {
					  sTitle : oList.get_entityTypeName()
					, sDisplayName : oList.get_title()
					, sDescription : oList.get_description()
					, guid : oList.get_id().toString()
					, nBaseTemplate : oList.get_baseTemplate()
					, bLibrary : oList.get_baseType()
					, bList : ( ! oList.get_baseType() )
					, bHidden : oList.get_hidden()
					, lsContentTypes : lsContentTypes
				}
				laLists.push( aList );
			}
			async.resolve( { laLists : laLists } );
		}
	} );
}

// var xml = '<Field Type="Choice" Name="FrontOffice" DisplayName="Front Office" ';
//	xml += ' Format="Dropdown" Group="Custom Columns">';
//	xml += '<CHOICES><CHOICE>OSG</CHOICE><CHOICE>OCEEA</CHOICE></CHOICES></Field>';
// __.SP.site.addColumn( { xml : xml );

__.SP.site.addColumn = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oFields = ctx.get_web().get_fields();
	oFields.addFieldAsXml( args.xml );
	ctx.load( oFields );
	__.SP.exec( ctx, oFields, function( oFields ) {
		if( oFields.sError ) {
			async.reject( oFields );
		}
		else {
			async.resolve();
		}
	} );
};
// __.SP.site.readColumn({sColumn:"FrontOffice"})
__.SP.site.readColumn = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oFields = ctx.get_web().get_fields();
	var oWeb = ctx.get_site().get_rootWeb();
	var oColumn = oWeb.get_availableFields().getByInternalNameOrTitle( args.sColumn );
	ctx.load( oColumn );
	__.SP.exec( ctx, oColumn, function( oColumn ) {
		if( oColumn.sError ) {
			async.reject( oColumn );
		}
		else {
			var ls = [];
			var xml = oColumn.get_schemaXml();
			xml.match( /<CHOICE>(.*?)<\/CHOICE>/g ).forEach( function( s ) {
				ls.push( s.match( /<CHOICE>(.*?)<\/CHOICE>/ )[ 1 ] ) ;
			} );
			async.resolve( {
				lsValues : ls
			} );
		}
	} );
};

__.SP.site.addCSS = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var ctx = SP.ClientContext.get_current()
	var oWeb = ctx.get_web();
	oWeb.set_alternateCssUrl( args.url );
	oWeb.update();
	__.SP.exec( ctx, oWeb, function( oWeb ) {
		if( oWeb.sError ) {
			async.reject( oWeb.sError );
		}
		else {
			async.resolve();
		}
	} );
};

/**
 * @namespace __.SP.search
 * @memberof __.SP
 */

__.SP.search = {};

__.SP.search.loadSPScripts = function( args ) {
	var async = __.Async.promise( args );
	var hdTimeout = setTimeout( function() {
		async.reject( "Could not load search component from SharePoint" );
	}, 10000 );
	SP.SOD.executeFunc("SP.js", "SP.ClientContext", function () {
		SP.SOD.executeFunc("SP.Search.js", "Microsoft.SharePoint.Client.Search.Query.KeywordQuery", function () {
			clearTimeout( hdTimeout );
			async.resolve();
		} );
	} );
};
/*
*/

/**
 * Searches the index for keywords. Use 
 * @memberof __.SP.search
 * @method keyword
 * @async 
 * @instance
 * @example // searches for all task for current user
 * __.SP.search.keyword( {
 * 	  sQuery : 'ContentTypeId:0x0108* AssignedToOWSUSER:"' + __.SP.user.aInfo.sLogin + '"'
 * 	, lsProps : [ "Title", "AssignedToOWSUSER", "StatusOWSCHCS", "ListId", "Created" ]
 * 	, cb : function( laResult ) { console.log( laResult ); }
 * } );
 * __.SP.workflow.myTasks();
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sQuery keyword query
 * @param {Array} args.lsProps Additional properties to be included in the search result
 * @param {Function} [args.cb] optional callback function receiving the result.
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * oTasks | (Object) | data object holding search results
 * </pre>
 */


__.SP.search.keyword = function( args ) {
	var async = __.Async.promise( args );
	var sQuery = args.sQuery;
	if( ! sQuery ) {
		async.reject( "A query string is required for the search" );
		return;
	}
	var lsProps = args.lsProps || null;
	async.then( __.SP.search, "loadSPScripts", "Load search API scripts" )
	async.then( function( args ) {
		var ctx =  new SP.ClientContext();
		var oQuery = new Microsoft.SharePoint.Client.Search.Query.KeywordQuery( ctx );
		if( lsProps ) {
			var oProps = oQuery.get_selectProperties();
			lsProps.forEach( function( sProp ) {
				oProps.add( sProp );
			} );
		}
		oQuery.set_queryText( sQuery );
		var oExecutor = new Microsoft.SharePoint.Client.Search.Query.SearchExecutor( ctx );
		var oResults = oExecutor.executeQuery( oQuery );
		ctx.executeQueryAsync(
			function () {
				if( 	oResults &&
					oResults.m_value &&
					oResults.m_value.ResultTables && 
					oResults.m_value.ResultTables[ 0 ] &&
					oResults.m_value.ResultTables[ 0 ].ResultRows ) {
					async.resolve( { loResults : oResults.m_value.ResultTables[ 0 ].ResultRows } );
				}
				else {
					async.reject( "Could not perform a search" );
				}
			}
		);
	}, "Execute search" );
	async.resolve();
}
/**
 * @namespace __.SP.folder
 * @memberof __.SP
 */
__.SP.folder = {
	/**
	 * Creates a folder in a document library
	 * @memberof __.SP.folder
	 * @method create
	 * @example __.SP.folder.create( {
	 * 	  sList : "Shared Documents"
	 * 	, sFolder "test folder"
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name of the list
	 * @param {String} args.sFolder name of the folder
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre>
	 * oFolder  | (Object) | context of the newly created folder
	 * idFolder | (Number) | item ID of the newly created folder
	 * </pre>
	 */
	  create : function( args ) { // sList, sFolder
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var path = "";
		var sFolder = args.sFolder;
		if( /\//.test( args.sFolder ) ) {
			var ls = args.sFolder.split( "/" );
			sFolder = ls.pop();
			path = _spPageContextInfo.webServerRelativeUrl;
			path += "/" + args.sList + "/" + ls.join( "/" );
		}
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = new SP.ListItemCreationInformation();
		oItem.set_underlyingObjectType( SP.FileSystemObjectType.folder );
		oItem.set_leafName( sFolder );
		oItem.set_folderUrl( path );
		var oItem = oList.addItem( oItem );
		// also add title for we might use folder in lookup
		oItem.set_item( "Title", sFolder );
		oItem.update();
		ctx.load( oItem );
		__.SP.exec( ctx, oItem, function( oFolder ) {
			if( oFolder.sError ) {
				async.reject( oFolder.sError );
			}
			else {
				var id = oFolder.get_id();
				async.resolve( { oFolder : oFolder, idFolder : id });
			}
		} );
	}
	/**
	 * Reads information of a folder
	 * @memberof __.SP.folder
	 * @method read
	 * @example // stand alone
	 * __.SP.folder.read( {
	 * 	  path : "/Lists/Shared Documents/test folder"
	 * } );
	 * @example // as promise
	 * .then( __.SP.folder, "read", {
	 * 	  path : "/Lists/Shared Documents/test folder"
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} path path of the folder
	 * @param {Array} lsFields array of internal field names to return
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * oFolder | (Object) | context of the newly created folder
	 * aResult  | (Object) | associate array holding properties of the folder
	 * </pre>
	 */
	, read : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oFolder = ctx.get_web().getFolderByServerRelativeUrl( args.path );
		ctx.load( oFolder, "ListItemAllFields" );
		__.SP.exec( ctx, oFolder, function( oFolder ) {
			if( oFolder.sError ) {
				async.reject( oFolder.sError );
			}
			else {
				oFolder = oFolder.get_listItemAllFields();
				var aResult = {};
				args.lsFields.forEach( function( sField ) {
					var oField = oFolder.get_item( sField );
					if( oField ) {
						if( oField.get_lookupId ) {
							aResult[ sField ] = oField.get_lookupValue();
							aResult[ "id" + sField ] = oField.get_lookupId();
						}
						else {
							aResult[ sField ] = oField;
						}
					}
				} );
				async.resolve( { oFolder : oFolder, aResult : aResult } );
			}
		} );
	}
};
__.SP.folder.content = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var path = _spPageContextInfo.webServerRelativeUrl + "" + unescape( args.path );
	var mpQuery = {
		  "folders" : 	"<View><Query><Where> \
				<Eq>\
					<FieldRef Name='FSObjType' />\
					<Value Type='Integer'>1</Value>\
				</Eq>\
				</Where> \
				<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy> \
				</Query></View>"
		, "files" : 	"<View><Query><Where> \
				<Neq>\
					<FieldRef Name='FSObjType' />\
					<Value Type='Integer'>1</Value>\
				</Neq>\
				</Where> \
				<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy> \
				</Query></View>"
	};
	var viewXml = "<View> \
		<Query><Where> \
			<Eq>\
				<FieldRef Name='FSObjType' />\
				<Value Type='Integer'>1</Value>\
			</Eq>\
			</Where> \
			<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy>\
		</Query></View>";
	var oQuery = new SP.CamlQuery;
	oQuery.set_folderServerRelativeUrl( path );
	if( args.xmlQuery ) {
		oQuery.set_viewXml( args.xmlQuery );
	}
	else if( args.sFilter ) {
		var xmlQuery = mpQuery[ args.sFilter ];
		if( xmlQuery ) {
			oQuery.set_viewXml( xmlQuery );
		}
	}
	var oList = __.SP.list.get( ctx, args.sList );
	var oItems = oList.getItems( oQuery );
	var lsFields = [ "ContentType", "FileLeafRef", "ServerUrl", "DisplayName", "ID", "FileSystemObjectType" ];
	if( args.lsFields ) {
		lsFields = lsFields.concat( args.lsFields );
	}
	var sInclude = "Include( " + lsFields.join( "," ) + " )";
	ctx.load( oItems, sInclude );
	__.SP.exec( ctx, oItems, function( oItems ) {
		if( oItems.sError ) {
			async.reject( oItems.sError );
		}
		else {
			var laItems = [];
			var loItems = oItems.getEnumerator();
			while( loItems.moveNext() ) {
				var oItem = loItems.get_current();
				var bFolder = oItem.get_fileSystemObjectType();
				var url = oItem.get_item( 'ServerUrl' );
				if( bFolder ) {
					url = _spPageContextInfo.webServerRelativeUrl;
					url += "/_layouts/15/start.aspx#/SiteAssets/Forms/AllItems.aspx?RootFolder=";
					url += oItem.get_item( 'ServerUrl' );
				}
				var aItem = {
					  sTitle : oItem.get_item( 'FileLeafRef' )
					, sContentType : oItem.get_contentType().get_name()
					, idContentType : oItem.get_contentType().get_id().get_stringValue()
					, sDisplayName : oItem.get_displayName()
					, url : url
					, id : oItem.get_item( 'ID' )
					, bFolder : bFolder
				}
				if( args.lsFields ) {
					args.lsFields.forEach( function( sField ) {
						aItem[ sField ] = oItem.get_item( sField );
					} );
				}
				laItems.push( aItem );
			}
			async.resolve( { laItems : laItems } );
		}
	} );
}
/*
__.SP.folder.content( {
	  path : "/SiteAssets/Osce/Osce.Conman/"
	, sList : "Site Assets"
	, lsFields : [ "Author", "Modified" ]
	, cb : function( a ) {
		//console.log( a );
	}
} );
*/
__.SP.folder.content = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var path = _spPageContextInfo.webServerRelativeUrl + "" + unescape( args.path );
	var mpQuery = {
		  "folders" : 	"<View><Query><Where> \
				<Eq>\
					<FieldRef Name='FSObjType' />\
					<Value Type='Integer'>1</Value>\
				</Eq>\
				</Where> \
				<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy> \
				</Query></View>"
		, "files" : 	"<View><Query><Where> \
				<Neq>\
					<FieldRef Name='FSObjType' />\
					<Value Type='Integer'>1</Value>\
				</Neq>\
				</Where> \
				<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy> \
				</Query></View>"
	};
	var viewXml = "<View> \
		<Query><Where> \
			<Eq>\
				<FieldRef Name='FSObjType' />\
				<Value Type='Integer'>1</Value>\
			</Eq>\
			</Where> \
			<OrderBy><FieldRef Name='FileLeafRef' Ascending='True' /></OrderBy>\
		</Query></View>";
	var oQuery = new SP.CamlQuery;
	oQuery.set_folderServerRelativeUrl( path );
	if( args.xmlQuery ) {
		oQuery.set_viewXml( args.xmlQuery );
	}
	else if( args.sFilter ) {
		var xmlQuery = mpQuery[ args.sFilter ];
		if( xmlQuery ) {
			oQuery.set_viewXml( xmlQuery );
		}
	}
	var oList = __.SP.list.get( ctx, args.sList );
	var oItems = oList.getItems( oQuery );
	var lsFields = [ "ContentType", "FileLeafRef", "ServerUrl", "DisplayName", "ID", "FileSystemObjectType" ];
	if( args.lsFields ) {
		lsFields = lsFields.concat( args.lsFields );
	}
	var sInclude = "Include( " + lsFields.join( "," ) + " )";
	ctx.load( oItems, sInclude );
	__.SP.exec( ctx, oItems, function( oItems ) {
		if( oItems.sError ) {
			async.reject( oItems.sError );
		}
		else {
			var laItems = [];
			var loItems = oItems.getEnumerator();
			while( loItems.moveNext() ) {
				var oItem = loItems.get_current();
				var bFolder = oItem.get_fileSystemObjectType();
				var url = oItem.get_item( 'ServerUrl' );
				if( bFolder ) {
					url = _spPageContextInfo.webServerRelativeUrl;
					url += "/_layouts/15/start.aspx#/SiteAssets/Forms/AllItems.aspx?RootFolder=";
					url += oItem.get_item( 'ServerUrl' );
				}
				var aItem = {
					  sTitle : oItem.get_item( 'FileLeafRef' )
					, sContentType : oItem.get_contentType().get_name()
					, idContentType : oItem.get_contentType().get_id().get_stringValue()
					, sDisplayName : oItem.get_displayName()
					, url : url
					, id : oItem.get_item( 'ID' )
					, bFolder : bFolder
				}
				if( args.lsFields ) {
					args.lsFields.forEach( function( sField ) {
						aItem[ sField ] = oItem.get_item( sField );
					} );
				}
				laItems.push( aItem );
			}
			async.resolve( { laItems : laItems } );
		}
	} );
}
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.webpart; __.SP.webpart.settings; 
// ==/ClosureCompiler==


/**
 * @namespace __.SP.webpart
 * @memberof __.SP
 */
__.SP.webpart = {
	/**
	 * Updates settings of a webpart.
	 * @memberof __.SP.webpart
	 * @method settings
	 * @todo complete example
	 * @todo provide list of properties available
	 * @example
	 * __.SP.item.create( {
	 * 	  path : "path to aspx page?"
	 *	, ixWP : 2
	 *	, kv : {
	 * 		JSLink? : "path/to/jslink"
	 * 	}
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.path path to aspx page holding the webpart
	 * @param {Number} [args.ixWP] index of webpart if page has multiple (default is: 0)
	 * @param {String} [args.kv] key/value pairs of properties to update
	 */
	  settings : function( args ) { // path, ixWP, kv
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var path = ( /^http/.test( args.path ) )
			? args.path
			: _spPageContextInfo.webServerRelativeUrl + args.path;
		var oFile = ctx.get_web().getFileByServerRelativeUrl( path );
		var oWPM = oFile.getLimitedWebPartManager( SP.WebParts.PersonalizationScope.shared );
		var loWP = oWPM.get_webParts();
		ctx.load( loWP );
		__.SP.exec( ctx, loWP, function( loWP ) {
			if( loWP.sError ) {
				async.reject( loWP.sError );
			}
			else {
				var oDef = null;
				oDef = loWP.get_item( args.ixWP || 0 );
				if( ! oDef ) {
					async.reject( { sError : "No webpart with index: " + args.ixWP } );
				}
				else {
					var oProp = oDef.get_webPart().get_properties();
					ctx.load( oProp );
					__.SP.exec( ctx, oProp, function( oProp ) {
						if( oProp.sError ) {
							async.reject( oProp.sError );
						}
						else {
							for( var k in args.kv ) {
								var v = args.kv[ k ];
								oProp.set_item( k, v );
							}
							oDef.saveWebPartChanges();
							ctx.load( oDef );
							__.SP.exec( ctx, oDef, function( o ) {
								if( o.sError ) {
									async.reject( o.sError );
								}
								else {
									async.resolve();
								}
							} );
						}
					} );
				}
			}
		} );
	}
}
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.modal; __.SP.modal.alert; __.SP.modal.bExists; __.SP.modal.confirm; __.SP.modal.load; __.SP.modal.open; __.SP.modal.resize;
// ==/ClosureCompiler==


/**
 * @namespace __.SP.modal
 * @memberof __.SP
 */

__.SP.modal = {
	  dn : null
	/**
	 * Loads a page into a modal window
	 * @memberof __.SP.modal
	 * @method load
	 * @example __.SP.modal.load( {
	 *	  sTitle : "Manage taxonomies"
	 *	, url : "/link/to/taxonomy.aspx"
	 *	, fnLoad: function( dnModal ) {
	 *		var dnButton = dnModal.getElementById( "#add" );
	 * 		__.dn.del( dnButton );
	 *	}
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sTitle title of modal window
	 * @param {String} args.url Url to be loaded into the modal window
	 * @param {Function} [args.fnLoad] function to be called when the page was loaded.
	 * @param {Function} [args.fnClose] function to be called when the window gets closed (A number gets passed on indicating whether it was closed by cancelling (0) or clicking the "OK/Save" button (1)).
	 * @returns {Object} the modal object 
	 */
	, load : function( args ) {
		args.bClose = ( typeof args.bClose != "undefined" ) ? args.bClose : true;
		var kv = {
			  title : args.sTitle
			, showClose : args.bClose
			, autoSize : true
			, url : args.url
			, dialogReturnValueCallback : function( b ) {
				if( args.fnClose ) {
					args.fnClose( b );
				}
			}
		};
		var dnModal = SP.UI.ModalDialog.showModalDialog( kv );
		( new __.Async( {
			  id : "__.SP.modal.load"
			, sdftError : "Failed to load window page."
		} ) )
		.wait( function() {
			if( dnModal && dnModal.$e_0 ) {
				if( args.fnLoad ) {
					args.fnLoad( dnModal.$e_0 );
				}
				return true;
			}
			return false;
		}, 50 )
		.start();
		return this;
	}
	/**
	 * Opens a modal window
	 * @memberof __.SP.modal
	 * @method open
	 * @example __.SP.modal.confirm( {
	 *	  sTitle : "Save a filter"
	 *	, hContent : "name: <input id='filter' type='text'></input>"
	 *	, fnact : function( oModal ) {
	 *		var sName = oModal.dn.getElementById( "#filter" ).value();
			// save filter with sName
	 *	}
         *	, sCancel : null
         *	, bClose : false
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sTitle title of modal window
	 * @param {String} args.hContent content of modal window in HTML format
	 * @param {String} [args.sOk] name of main action button (OK/Save), indicatng "null" will not render the button (default is "Save")
	 * @param {String} [args.sCancel] name of cancel button, indicating "null" will not render the button (default is "Cancel" )
	 * @param {Boolean} [args.bClose] flag wether a button to close the modal window is rendered (X in top right corner)
	 * @param {Function} [args.fnClose] function to be called when the window gets closed (A number gets passed on indicating whether it was closed by cancelling (0) or clicking the "OK/Save" button (1)).
	 * @param {Function} [args.fnact] function to be called when the main action button is clicked
	 * @param {String} [args.sLoading] message to be shown when {args.fnact} is called or when {args.bShowProcessing} is flagged true (default is "Processing your request.")
	 * @param {Boolean} [args.bShowProcessing] flag to show the "in progress" modus (spinning wheel + message).
	 * @returns {Object} the modal object 
	 */
	, open : function( args ) {
		args.sLoading = args.sLoading || "Processing your request.";
		args.sOk = ( args.hasOwnProperty( "sOk" ) ) ? args.sOk : "Save";
		args.sCancel = ( args.hasOwnProperty( "sCancel" ) ) ? args.sCancel : "Cancel";
		args.bClose = ( typeof args.bClose != "undefined" ) ? args.bClose : true;
		var h = "<div id='osce-modal'>";
		h += args.hContent;
		h += "<p class='separator'></p>";
		h += this.buttons( args );
		h += "</div>";
		this.dn = document.body.__append( h );
		this.behaviour( this.dn, args );
		var kv = {
			  title : args.sTitle
			, showClose : args.bClose
			, autoSize : true
			, html : this.dn
			, dialogReturnValueCallback : function( b ) {
				if( args.fnClose ) {
					args.fnClose( b );
				}
			}
		};
		if( args.bShowProcessing ) {
			this.processing();
		}
		if( args.bNoButtons ) {
			this.dn.__find( ".osce-buttons" ).style.display = "none";
		}
		SP.UI.ModalDialog.showModalDialog( kv );
		return this;
	}
	, behaviour : function( dn, args ) {
		var that = this;
		var dnOk = this.dn.__find( "input[value='" + args.sOk + "']" );
		if( dnOk && args.fnact ) {
			dnOk.addEventListener( "click", function() {
				that.processing();
				args.fnact( that );
			} );
		}
		var dnCancel = this.dn.__find( "input[value='" + args.sCancel + "']" );
		if( dnCancel ) {
			dnCancel.addEventListener( "click", function() {
				__.SP.modal.cancel();
			} );
		}
		// set focus on first input field
		setTimeout( function() {
			var dnInput = that.dn.__find( "input" );
			if( dnInput && dnInput[ 0 ] && dnInput[ 0 ].focus ) {
				dnInput[ 0 ].focus();
			}
		}, 1500 );
	}
	, message : function( s ) {
		var dnMessage = this.dn.__find( ".osce-message" );
		var dnLoading = this.dn.__find( ".osce-loading" );
		if( s ) {
			dnMessage.textContent = s;
			dnMessage.style.display = "block";
			dnLoading.style.display = "none";
		}
		else {
			dnMessage.textContent = "";
			dnMessage.style.display = "none";
		}
	}
	, buttons : function( args ) {
		var h = "<div class='osce-action-panel'>";
		h += "  <div class='osce-message'></div>";
		h += "  <div class='osce-loading'>";
		h += "   <img src='" + __.SP.icon.mp.x16.loading + "' />";
		h += "   <span>" + args.sLoading + "</span></div>";
		h += "  <div class='osce-buttons'>";
		if( args.sOk ) {
		h += "  <input type='button' value='" + args.sOk + "'";
		h += "   accesskey='O' class='ms-ButtonHeightWidth'>";
		}
		if( args.sCancel ) {
		h += "  <input type='button' value='" + args.sCancel+ "'";
		h += "   accesskey='1' class='ms-ButtonHeightWidth'>";
		}
		h += "  </div>";
		h += "</div>";
		return h;
	}
	, stopProcessing : function() {
		var dnLoading = this.dn.__find( ".osce-loading" );
		dnLoading.style.display = "none";
	}
	, processing : function() {
		var dnLoading = this.dn.__find( ".osce-loading" );
		dnLoading.style.display = "block";
	}
	, progress : function( s ) {
		var dnMessage = this.dn.__find( ".osce-loading > span" );
		dnMessage.textContent = s;
	}
	, close : function() {
		SP.UI.ModalDialog.commonModalDialogClose( 1 );
	}
	, cancel : function() {
		var dnClose = document.body.__find( ".ms-dlgCloseBtn" );
		if( dnClose && dnClose.click ) {
			dnClose.click();
		}
		else {
			this.closeAll();
		}
	}
	/**
	 * Opens a confirmation window with a question plus "Yes"/"No" buttons.<br>
	 * Invokes a passed on callback function with a boolean indicating the answer.
	 * @memberof __.SP.modal
	 * @method confirm 
	 * @example __.SP.modal.confirm( {
	 *	  sTitle : "Confirm this action"
	 *	, sQuestion : "Do you want to remove the item?"
	 *	, fnAnswer : function( a ) {
	 *		console.log( a );
	 *	}
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} [args.sTitle] title of confirmation window (default is "Confirm this action..."
	 * @param {String} args.sQuestion question to ask the user (default is "Do you want to proceed?")
	 * @param {String} args.fnAnswer callback invoked with the answer as parameter
	 * @returns {Object} the modal object 
	 */
	, confirm : function( args ) {
		var s = ( args.sError ) ? args.sError : args;
		var hQuestion = ( args.sQuestion )
			? "<p>" + args.sQuestion + "</p>"
			: "<p>Do you want to proceed?</p>";
		return __.SP.modal.open( {
			  sTitle : args.sTitle || "Confirm this action..."
			, hContent : hQuestion
			, sOk : "Yes"
			, sCancel : "No"
			, fnact : function() {
				__.SP.modal.close();
			}
			, fnClose : args.fnAnswer || null
		} );
	}
	/**
	 * Opens a modal alert window with a list of items to select.
	 * @memberof __.SP.modal
	 * @method select
	 * @example __.SP.modal.select( {
	 *	  sTitle : "Select box"
	 *	, sMessage : "Please select some items"
	 *	, laItems : [
	 *		  { sItem : "item1", vItem : "123", bSelected : true }
	 *		, { sItem : "item2", vItem : "abc" }
	 *		, { sItem : "item3", vItem : "x1f" }
	 *	]
	 * 	, cb : function( lsItems ) {
	 *		// do sg with selection
	 * 	}
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} [args.sTitle] title of alert window (default is "System Message"
	 * @param {String} [args.sMessage] message of the alert.
	 * @param {String} args.laItems list of of key value pairs (sItem/vItem) of selected items
	 * @param {String} args.cb callback receiving list of of key value pairs (sItem/vItem) of selected items
	 * @returns {Object} the modal object 
	 */
	, select : function( args ) {
		var sMessage = ( args.sMessage ) ? args.sMessage : "";
		var h = "<p>" + sMessage + "</p>";
		h += "<table>";
		args.laItems.forEach( function( aItem ) {
			var sChecked = ( aItem.bSelected ) ? " checked " : "";
			h += "<tr>";
			h += "<td>";
			h += "<input type='checkbox' ";
			h += "name='" + aItem.sItem + "' ";
			h += "value='" + aItem.vItem + "' >";
			h += "<td>";
			h += aItem.sItem;
			h += "</td>";
			h += "</tr>";
		} );
		h += "</table>";
		return __.SP.modal.open( {
			  sTitle : args.sTitle || "Select items"
			, hContent : h
			, fnact : function( oModal ) {
				var laItems = [];
				oModal.dn.__find( "input[value]" ).__each( function( dn ) {
					if( dn.checked ) {
						laItems.push( {
							  sItem : dn.name
							, vItem : dn.value
						} );
					}
				} );
				args.cb( laItems );
				__.SP.modal.close();
			}
		} );
	}
	/**
	 * Opens a modal alert window with a message.
	 * @memberof __.SP.modal
	 * @method alert
	 * @example __.SP.modal.alert( {
	 *	  sMessage : "You cannot perform this action until you checkout"
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} [args.sTitle] title of alert window (default is "System Message"
	 * @param {String} args.sMessage message of the alert.
	 * @returns {Object} the modal object 
	 */
	, alert : function( args ) {
		var sMessage = ( args.sMessage ) ? args.sMessage : "";
		var h = "<p>" + sMessage + "</p>";
		return __.SP.modal.open( {
			  sTitle : args.sTitle || "System Message"
			, hContent : h
			, sOk : null
			, sCancel : "Close"
		} );
	}
	, closeAll : function() {
		console.log( 'closeall' );
		document.body.__find( ".ms-dlgContent", function( dnModal ) {
			dnModal.__remove();
		} );
		document.body.__find( ".ms-dlgOverlay", function( dnBlend ) {
			dnBlend.__remove();
		} );
	}
	/**
	 * Checks if a modal window is currently displayed.
	 * @memberof __.SP.modal
	 * @method bExists
	 * @example var bModalOpen = __.SP.modal.bExists();
	 * @returns {Boolean} true if a modal window is currently displayed
	 */
	, bExists : function() {
		return document.body.__find( ".ms-dlgContent" );
	}
	/**
	 * Resizes the current modal window to fit the content.
	 * @memberof __.SP.modal
	 * @method resize
	 * @example __.SP.modal.resize();
	 */
	, resize : function() {
		var oModal = SP.UI.ModalDialog.get_childDialog();
		oModal.$$d_autoSize();
	}
};

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @output_file_name __.sp.list.min.js
// @js_externs var __; __.SP; __.SP.ctx
// ==/ClosureCompiler==


/**
 * @namespace __.SP.list
 * @memberof __.SP
 */

__.SP.list = {
	/**
	 * Gets a list context by name or guid
	 * @memberof __.SP.list
	 * @method get
	 * @todo use arguments object
	 * @todo improve error capturing
	 * @example __.SP.folder.get( ctx, "Documents" );
	 * @param {Object} ctx SharePoint site context
	 * @param {String} x either name of the list or its guid in curly brackets
	 * @returns {Object} context of the list
	 */
	  get : function( ctx, x ) {
		var oList = null;
		var oLists = ctx.get_web().get_lists();
		// remove any curly brackets if present
		x = x.replace( /{|}/g, "" )
		if( __.SP.bGuid( x ) ) {
			oList = oLists.getById( x );
		}
		else {
			oList = oLists.getByTitle( x );
		}
		return ( oList ) ? oList : null;
	}
	/**
	 * Reads list items
	 * @memberof __.SP.list
	 * @method read
	 * @example
	 * __.SP.list.read( {
	 * 	  sList : "Documents"
	 *	, lsFields : [ "Title", "ID" ]
	 *	, xmlQuery : "<Where><FieldRef Name='ID' /><Lt><Value Type='Number'>5</Value></Lt></Where>"
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Array} args.lsFields array of field names to be returned
	 * @param {String} [args.sSite] Url of a site (defaults to current)
	 * @param {String} [args.pathSearch] folder path to start search from
	 * @param {String} [args.xmlQuery] optional CAML query otherwise entire list is returned
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * lkv | (Object) | array of key value pairs
	 * </pre>
	 */
	, read : function( args ) { // sList, lsFields, xmlQuery, pathSearch (to limit to subfolder)
		var async = __.Async.promise( args );
		// get context
		var ctx = __.SP.ctx( args );
		// get list
		var oList = __.SP.list.get( ctx, args.sList );
		if( ! oList ) {
			async.reject( "List not found: " + args.sList );
		}
		else {
			var oQuery;
			if( args.xmlQuery ) {
				oQuery = new SP.CamlQuery();
				oQuery.set_viewXml( "<View>" + args.xmlQuery + "</View>" );
			}
			else {
				oQuery = SP.CamlQuery.createAllItemsQuery();
			}
			if( args.pathSearch ) {
				// not tested
				oQuery.set_folderServerRelativeUrl( args.pathSearch );
			}
			var lsFields = args.lsFields || [ "ID" ];
			var oItems = oList.getItems( oQuery );
			ctx.load( oItems );
			__.SP.exec( ctx, oItems, function( oItems ) {
				if( oItems.sError ) {
					async.reject( oItems.sError );
				}
				else {
					var lkv = [];
					var laItems = oItems.getEnumerator();
					while( laItems.moveNext() ) {
						var kv = {};
						var kvItem = laItems.get_current().get_fieldValues();
						if( lsFields.length > 0 ) {
							lsFields.forEach( function( sField ) {
								var oField = kvItem[ sField ];
								// we also want to show empty fields that are sent back
								// with null, hence check of type
								if( typeof oField !== "undefined" ) {
									if( oField && oField.get_termGuid ) {
										kv[ sField ] = oField.get_label();
										kv[ "guid" + sField ] = oField.get_termGuid();
									}
									else if( oField && oField.get_lookupValue ) {
										kv[ sField ] = oField.get_lookupValue();
										kv[ "id" + sField ] = oField.get_lookupId();
									}
									else {
										kv[ sField ] = oField;
									}
								}
							} );
							lkv.push( kv );
						}
						else {
							lkv.push( kvItem );
						}
					}
					async.resolve( { lkv : lkv } );
				}
			} );
		}
	}
	/**
	 * OBSOLTE Reads fields from list view
	 */
	// REF: remove 
	// __.SP.list.readView ( {sList : "OSCE Contacts", sView : 111, lsFields : [ "Title", "Country" ], cb : function( a ) {	do( a.kv ); } ); } } )
	, readView : function( args ) { // sList, sView, lsFields, cb
		var cb = args.cb;
		var lsFields = args.lsFields;
		( new __.Async( {
			  id : "__.SP.list.readView"
			, sdftError : "Failed to read list view."
		} ) )
		.then( __.SP.view, "read", {
			  sList : args.sList
			, sView : args.sView
		} )
		.then( function( args ) {
			var async = __.Async.promise( args );
			async.then( __.SP.list, "read", {
				  sList : args.sList
				, lsFields : lsFields
				, xmlQuery : "<Query>" + args.kv.xmlQuery + "</Query>"
			} ).resolve();
		} )
		.then( function( args ) {
			cb( args );
			__.Async.promise( args ).resolve();
		} )
		.start();
	}
/**
 * <pre>
 * Check if a list exists
 * </pre>
 * @memberof __.SP.list
 * @method exists
 * @example
 * __.SP.list.exists( {
 * 	  sList : "Documents"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * bExists | (Boolean) | true if list exists otherwise false
 * </pre>
 */
	, exists : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		ctx.load( oList, 'Id' );
		__.SP.exec( ctx, oList, function( oList ) {
			if( oList.sError ) {
				async.resolve( { bExists : false } );
			}
			else {
				async.resolve( { bExists : true } );
			}
		} );
	}
};
/**
 * <pre>
 * Get guid of a list for a given name
 * </pre>
 * @memberof __.SP.list
 * @method id
 * @example
 * __.SP.list.id( {
 * 	  sList : "Documents"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of a list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * idList | (String) | guid of a list
 * </pre>
 */
__.SP.list.id = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	ctx.load( oList, 'Id' );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve( { idList : oList.get_id() } );
		}
	} );
}

/**
 * <pre>
 * Updates the settings of a list. Available properties are:
 * - documentTemplateUrl
 * - contentTypesEnabled
 * - enableMinorVersions
 * - enableVersioning
 * - onQuickLaunch
 * - majorVersionLimit
 * - majorWithMinorVersionsLimit
 * </pre>
 * @todo prefix "set_" to avoid inidcation in argument
 * @todo rename kvFeatures to aSettings
 * @memberof __.SP.list
 * @method settings
 * @example
 * __.SP.list.settings( {
 * 	  sList : "Documents"
 *	, kvFeatures : {
 * 		  set_enableVersioning : true
 *		, set_onQuickLaunch : false
 * 	}
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of a list
 * @param {Object} args.kvFeatures key value pair of settings
 */
__.SP.list.settings = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	for( var k in args.kvFeatures ) {
		var v = args.kvFeatures[ k ];
		oList[ k ]( v );
	}
	oList.update();
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
};


/**
 * <pre>
 * Creates a list of a give type
 * Available types:
 * - genericList
 * - discussionBoard
 * - documentLibrary
 * - announcements
 * - contacts
 * - events
 * - REF: more?
 * </pre>
 * @memberof __.SP.list
 * @method create
 * @example
 * __.SP.list.create( {
 * 	  sList : "simple list"
 *	, sType : "genericList"
 * 	, sDescription : "This is a simple list"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of the list
 * @param {String} args.sType type of the list
 * @param {String} [args.sDescription] description of the list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * oList | (Object) | context of the list
 * </pre>
 */
__.SP.list.create = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oWeb = ctx.get_web();
	var oInfo = new SP.ListCreationInformation();
	oInfo.set_title( args.sList );
	oInfo.set_templateType( SP.ListTemplateType[ args.sType ] );
	var oList = oWeb.get_lists().add( oInfo );
	if( args.sDescription ) {
		oList.set_description( args.sDescription );
	}
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve( { oList : oList } );
		}
	} );
}

/**
 * <pre>
 * Deletes a list
 * </pre>
 * @memberof __.SP.list
 * @method del
 * @example
 * __.SP.list.del( {
 * 	  sList : "simple list"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of the list
 */
__.SP.list.del = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	oList.deleteObject();
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
};

__.SP.list.xmlFields = function( args ) {
	var mp = {
		  taxonomy : "TaxonomyFieldType"
		, lookup : "Lookup"
		, choice : "Choice"
		, textarea : "Note"
		, input : "Text"
		, checkbox : "Boolean"
		, boolean : "Boolean"
		, date : "DateTime"
	};
	var xml = '<Field Name="' + args.sName + '" DisplayName="' + args.sName + '" ';
	if( args.sAddition ) {
		xml += args.sAddition;
	}
	var sType = mp[ args.sCAMLType ];
	// its a site column...
	if( sType == "DateTime" ) {
		xml += ' Format="DateOnly" ';
	}
	if( args.bMulti ) {
		sType = ( sType == "Choice" )
			? "MultiChoice"
			: sType += "Multi";
		xml += ' Mult="TRUE" ';
	}
	if( args.aCalculation ) {
		xml += ' ReadOnly="TRUE" Type="Calculated">';
		xml += "<Formula>" + args.aCalculation.sFormular + "</Formula>";
		xml += "<FieldRefs>";
		args.aCalculation.lsFields.forEach( function( sField ) {
			xml += "<FieldRef Name=\"" + sField + "\" />";
		} );
		xml += "</FieldRefs>";
	}
	else {
		xml += ' Type="' + sType + '">';
	}
	if( sType == "TaxonomyFieldType" ) {
		// REF: move this to __.SP.taxonomy
		var guidTermStore = __.SP.taxonomy.oStore.guidTermStore;
		var guidTermSet = __.SP.taxonomy.oStore.guidTermSet[ args.sTaxonomy ];
		xml += '<Customization>';
		xml += '<ArrayOfProperty>';
		xml += '<Property><Name>SspId</Name><Value xmlns:q1="http://www.w3.org/2001/XMLSchema" p4:type="q1:string" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance">' + guidTermStore + '</Value></Property>';
		xml += '<Property><Name>TermSetId</Name><Value xmlns:q2="http://www.w3.org/2001/XMLSchema" p4:type="q2:string" xmlns:p4="http://www.w3.org/2001/XMLSchema-instance">' + guidTermSet + '</Value></Property>';
		xml += '</ArrayOfProperty>';
		xml += '</Customization>';
	}
	if( typeof args.vDefault !== "undefined" ) {
		xml += '<Default>' + args.vDefault + '</Default>';
	}
	xml += '</Field>';
	return xml;
};
__.SP.list.oFieldType = function( args ) {
	var mp = {
		  taxonomy : SP.Taxonomy.TaxonomyField
		, lookup : SP.FieldLookup
		, choice : SP.FieldChoice
		, input : SP.FieldText
		, textarea : SP.FieldText
		, checkbox : SP.FieldText
		, boolean : SP.FieldText
		, date : SP.FieldDateTime
	};
	return mp[ args.sCAMLType ];
};

/**
 * @typedef oField
 * @property {String} sName internal name of a field
 * @property {String} sDisplayName display name of a field
 */
/**
 * <pre>
 * Adds fields to a list
 * </pre>
 * @memberof __.SP.list
 * @method addFields
 * @async 
 * @instance
 * @todo move to namespace __.SP.list.fields
 * @todo check need of return value loFields
 * @todo check if single updates prevent calulated fields from erroring out
 * @example
 * __.SP.list.addFields( {
 * 	  sList : "simple list"
 *	, loFields : loFields
 * } );
 * @param {Object} args 
 * @param {String} args.sList name of the list
 * @param {oField} args.loFields an array of list field objects "oField"
 */
__.SP.list.addFields = function( args ) { // sList, loFields
	var async = __.Async.promise( args );
	async.then( __.SP.taxonomy, "loadSPScripts" )
	async.then( function( args ) {
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		if( args.loFields ) {
			var oFields = oList.get_fields();
			args.loFields.forEach( function( a ) {
				if( a.sCAMLType !== "column" && a.sName !== "Title" ) {
					var oField = ctx.castTo(
						  oFields.addFieldAsXml(
							  __.SP.list.xmlFields( a )
							, true
							, SP.AddFieldOptions.addToDefaultContentType
						)
						, __.SP.list.oFieldType( a )
					);
					if( a.sTitle ) {
						oField.set_title( a.sTitle );
					}
					if( a.sDescription ) {
						oField.set_description( a.sDescription );
					}
					if( a.lsChoices ) {
						oField.set_choices( a.lsChoices );
					}
					if( a.aLookup ) {
						a.aLookup.oField = oField;
					}
					if( a.vDefault ) {
						oField.set_defaultValue( a.vDefault );
					}
					oField.update();
					ctx.load( oField );
				}
			} );
			__.SP.exec( ctx, oFields, function( oFields ) {
				if( oFields.sError ) {
					if( /Cannot complete this action/.test( oFields.sError ) ) {
						async.resolve();
					}
					else {
						async.reject( oFields.sError );
					}
				}
				else {
					async.resolve();
				}
			} );
		}
	} );
	async.resolve();
}

/**
 * <pre>
 * Sets up a field as lookup
 * @todo move to field namespace or merge with field.update
 * @todo automatically get guid of list by name
 * </pre>
 * @memberof __.SP.list
 * @method setLookup
 * @example
 * __.SP.list.setLookup( {
 * 	  oField : oField
 *	, idList : "12345678-asdf-zxcv-qwwe-1234567890ab"
 * 	, sField : "Title"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {Object} args.oField context of list field
 * @param {idList} args.idList guid of lookup list
 * @param {sField} args.sField name of main lookup list field to display
 */
__.SP.list.setLookup = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oField = args.oField;
	oField.set_lookupList( "{" + args.idList + "}" );
	oField.set_lookupField( args.sField );
	oField.update();
	ctx.load( oField );
	__.SP.exec( ctx, oField, function( o ) {
		if( o.sError ) {
			async.reject( "setLookupErrorType " + o.sError );
		}
		else {
			async.resolve( { oField : oField });
		}
	} );
}

/**
 * <pre>
 * Sets up fields as lookup using a an array of {oFields}
 * @todo move to field namespace or merge with field.update
 * @todo check possibility to merge with {__.SP.field.setLookup}
 * </pre>
 * @memberof __.SP.list
 * @method setLookups
 * @example
 * __.SP.list.setLookups( { loFields : loFields } );
 * @param {Object} args a parameter object holding the following values
 * @param {Array|of|oField} args.loFields array of oField objects
 */
__.SP.list.setLookups = function( args ) {
	var async = __.Async.promise( args );
	args.loFields.forEach( function( o ) {
		if( o.aLookup ) {
			async.then( __.SP.list, "id", {
				sList : o.aLookup.sList
			} );
			async.then( __.SP.list, "setLookup", {
				  oField : o.aLookup.oField
				, sField : o.aLookup.sField
			} );
		}
	} );
	async.resolve();
}

// __.SP.list.setColumn( { sList : "FrontOfficeAssignments", sColumn : "FrontOffice"} )
/**
 * <pre>
 * Adds a site column to a list
 * @todo move to field namespace or merge with field.update
 * @todo check if we can merge with setColumns
 * </pre>
 * @memberof __.SP.list
 * @method setColumn
 * @example
 * __.SP.list.setColumn( {
 * 	  sList : "test list"
 *	, sColumn : "Email"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of list
 * @param {String} args.sColumn internal name of site column
 */
__.SP.list.setColumn = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oColumn = ctx.get_web().get_fields().getByInternalNameOrTitle( args.sColumn );
	var oList = __.SP.list.get( ctx, args.sList );
	var oField = oList.get_fields().add( oColumn );
	var oView = oList.get_defaultView();
	oView.get_viewFields().add( args.sColumn );
	oView.update();
	oList.update();
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
}

/**
 * <pre>
 * Adds columns to a list using a an array of {oFields}
 * @todo move to field namespace or merge with field.update
 * @todo check possibility to merge with {__.SP.field.setColumn}
 * </pre>
 * @memberof __.SP.setColumns
 * @method setColumns
 * @example
 * __.SP.list.setColumns( { loFields : loFields } );
 * @param {Object} args a parameter object holding the following values
 * @param {Array|of|oField} args.loFields array of oField objects
 */
__.SP.list.setColumns = function( args ) { // oList, loFields ) {
	var async = __.Async.promise( args );
	args.loFields.forEach( function( o ) {
		if( o.sColumn ) {
			async.then( __.SP.list, "setColumn", {
				  sColumn : o.sColumn
				, sList : args.sList
			} );
		}
	} );
	async.resolve();
}

/**
 * <pre>
 * Returns the name of a list for a given guid
 * </pre>
 * @memberof __.SP.list
 * @method nameByGuid
 * @example __.SP.list.nameByGuid( {
 *     guid : "b5ffd424-8b37-4bb8-b070-d32e4d638740"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.guid guid of a list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * sName | (String) | name of the list
 * </pre>
 */
__.SP.list.nameByGuid = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = ctx.get_web().get_lists().getById( args.guid );
	ctx.load( oList, "Title" );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve( {
				  sName : oList.get_title()
			} );
		}
	} );
};

/**
 * <pre>
 * Returns two objects mapping a lists internal field names against their display names and vice versa.
 * </pre>
 * @memberof __.SP.list
 * @method fields
 * @example __.SP.list.fields( { sList : "test list" } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of the list
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * mpIntNames | (Object) | maps internal names against display names
 * mpDispNames | (Object) | maps display names against internal names
 * </pre>
 */
__.SP.list.fields = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx( args );
	var oList = __.SP.list.get( ctx, args.sList );
	var oFields = oList.get_fields();
	var lsStandardFields = [ "Title", "Created", "Author" ];
	ctx.load( oFields, 'Include(Title,InternalName,FromBaseType)' );
	__.SP.exec( ctx, oFields, function( oFields ) {
		if( oFields.sError ) {
			async.reject( oFields.sError );
		}
		else {
			var laFields = oFields.getEnumerator();
			var mpIntNames = {};
			var mpDispNames = {};
			while( laFields.moveNext() ) {
				var aField = laFields.get_current();
				var sIntName = aField.get_internalName();
				var sDispName = aField.get_title();
				if( args.bOnlyCustom ) {
					if( ! aField.get_fromBaseType() ||
						lsStandardFields.__contains( sIntName ) ) {
						mpIntNames[ sIntName ] = sDispName;
						mpDispNames[ sDispName ] = sIntName;
					}
				}
				else {
					mpIntNames[ sIntName ] = sDispName;
					mpDispNames[ sDispName ] = sIntName;
				}
			}
			async.resolve( {
				  mpIntNames : mpIntNames
				, mpDispNames : mpDispNames
			} );
		}
	} );
};

/**
 * @namespace __.SP.list.field
 * @memberof __.SP.list
 */

__.SP.list.field = {};

/**
 * <pre>
 * Updates a list field with the following information
 * - display name
 * - flag to be required
 * - flag to be hidden
 * - flags in which forms to be shown
 * </pre>
 * @memberof __.SP.list.field
 * @method display
 * @example
 * __.SP.list.field.display( {
 * 	  sList : "test list"
 * 	, sField : "Title"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of the list
 * @param {String} args.sField internal name of the field
 * @param {String} args.sTitle new display name of the field
 * @param {Boolean} args.bRequired flag whether a field is required
 * @param {Boolean} args.bHidden flag whether to hide a field
 * @param {Boolean} args.bNew flag whether to not load in new form
 * @param {Boolean} args.bEdit flag whether to not load in edit form
 * @param {Boolean} args.bDisp flag whether to not load in view form
 */
// REF: rename sTitle to sDisplayName
// REF: think of merging with setLookup, setColumn and reanme method to update?
__.SP.list.field.display = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oField = oList.get_fields().getByInternalNameOrTitle( args.sField );
	var bDisp = ( typeof args.bDisp !== "undefined" ) ? args.bDisp : true;
	var bNew = ( typeof args.bNew !== "undefined" ) ? args.bNew : true;
	var bEdit = ( typeof args.bEdit !== "undefined" ) ? args.bEdit : true;
	var bHidden = ( typeof args.bHidden !== "undefined" ) ? args.bHidden : false;
	oField.setShowInDisplayForm( bDisp );
	oField.setShowInNewForm( bNew );
	oField.setShowInEditForm( bEdit );
	if( args.sTitle ) {
		oField.set_title( args.sTitle );
	}
	if( args.bRequired ) {
		oField.set_required( args.bRequired );
	}
	oField.set_hidden( bHidden );
	oField.update();
	ctx.load( oField );
	__.SP.exec( ctx, oField, function( oField ) {
		if( oField.sError ) {
			async.reject( oField.sError );
		}
		else {
			async.resolve();
		}
	} );
}


/**
 * <pre>
 * Adds columns to a list using a an array of {oFields}
 * @todo check possibility to merge with {__.SP.field.display}
 * @todo investigate error we get with "choice" fields
 * </pre>
 * @memberof __.SP.list.field
 * @method displays
 * @example
 * __.SP.list.displays( {
 *        sList : "test list"
 *      , loFields : loFields
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {Array|of|oField} args.loFields array of oField objects
 */
__.SP.list.field.displays = function( args ) {
	var async = __.Async.promise( args );
	args.loFields.forEach( function( oField ) {
		if( oField.sCAMLType !== "choice" ) {
			async.then( __.SP.list.field, "display", {
				  sList : args.sList
				, sField : oField.sName
				, sTitle : oField.sDisplayName
				, bNew : oField.bNew
				, bEdit : oField.bEdit
				, bDisp : oField.bDisp
				, bHidden : oField.bHidden
				, bRequired : oField.bRequired
				, vDefault : oField.vDefault
			}, "update " + oField.sName )
		}
	} );
	async.resolve();
}

/**
 * <pre>
 * Reorders fields of a list by an array of field names.
 * </pre>
 * @memberof __.SP.list.field
 * @method reorder
 * @example
 * __.SP.list.field.reorder( {
 *        sList : "test list"
 *      , lsFields : [ "Email", "CustomField", "Title" ]
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {Array} args.lsFields array of internal field names
 */
__.SP.list.field.reorder = function( args ) { 
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oCTs = oList.get_contentTypes();
	ctx.load( oCTs );
	__.SP.exec( ctx, oCTs, function( oCTs ) {
		if( oCTs.sError ) {
			async.reject( oCTs.sError );
		}
		else {
			var oCT = oCTs.getItemAtIndex( 0 );
			var oFields = oCT.get_fieldLinks();
			oFields.reorder( args.lsFields );
			oCT.update( false );
			__.SP.exec( ctx, oFields, function( oFields ) {
				if( oFields.sError ) {
					async.reject( oFields.sError );
				}
				else {
					async.resolve();
				}
			} );
		}
	} );
};

/**
 * Sets jsLink file on a field
 * @memberof __.SP.list.field
 * @method setJsLink
 * @example
 * __.SP.list.field.setJsLink( {
 *        sList : "OSCE Contacts"
 * 	, sField : "jsLink"
 * 	, urlJsLink : "~sitecollection/App/js/jsLink/jsLink_OCEEARegistrations_list.js?v=v5"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {Array} args.lsFields array of internal field names
 */
__.SP.list.field.setJsLink= function( args ) { // sList, [sField], urlJsLink
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var sField = args.sField || "jsLink";
	var oField = oList.get_fields().getByInternalNameOrTitle( sField );
	oField.set_jsLink( args.urlJsLink );
	oField.update();
	ctx.load( oField );
	__.SP.exec( ctx, oField, function( oField ) {
		if( oField.sError ) {
			async.reject( oField.sError );
		}
		else {
			async.resolve( "jsLink set" );
		}
	} );
};

/**
 * Breaks the permission inheritance of a list
 * @memberof __.SP.list
 * @method breakInheritance
 * @example
 * __.SP.list.breakInheritance( {
 * 	    sList : "Documents"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 */

__.SP.list.breakInheritance = function( args ) { // sList, id
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx( args );
	var oList = __.SP.list.get( ctx, args.sList );
	oList.breakRoleInheritance( false, false );
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
};

/**
 * Resets the original permission inheritance of a list
 * @memberof __.SP.list
 * @method resetInheritance
 * @example
 * __.SP.list.resetInheritance( {
 * 	    sList : "Documents"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 */
__.SP.list.resetInheritance = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	oList.resetRoleInheritance();
	ctx.load( oList );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
}

/**
 * Adds a group with a permission role to a list
 * @memberof __.SP.list
 * @method addGroup
 * @example
 * __.SP.list.addGroup( {
 * 	    sList : "Documents"
 *	  , sGroup : "Front Office OSG"
 *	  , sRole : "Read"
 * } );
 * @todo provide a full list of roles in documenation
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sGroup name of the group
 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
 */

__.SP.list.addGroup = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	ctx.load( oList );
	var oGroups = ctx.get_web().get_siteGroups();
	var oGroup = oGroups.getByName( args.sGroup );
	var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
	var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
	oBinding.add( oRole );
	oList.get_roleAssignments().add( oGroup, oBinding );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
};

/**
 * Wipes all exising permissions on an list and adds a group with a permission role to it.
 * @memberof __.SP.list
 * @method restrictToGroup
 * @example
 * __.SP.list.restrictToGroup( {
 * 	    sList : "Documents"
 *	  , sGroup : "Front Office OSG"
 *	  , sRole : "Read"
 * } );
 * @todo provide a full list of roles in documenation
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.sGroup name of the group
 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
 */

__.SP.list.restrictToGroup = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	ctx.load( oList );
	var oGroups = ctx.get_web().get_siteGroups();
	var oGroup = oGroups.getByName( args.sGroup );
	var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
	var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
	oBinding.add( oRole );
	oList.breakRoleInheritance( false );
	oList.get_roleAssignments().add( oGroup, oBinding );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
};

/**
 * Wipes all exising permissions on a list and adds a user with a permission role to it.
 * @memberof __.SP.list
 * @method restrictToUser
 * @example
 * __.SP.list.restrictToUser( {
 * 	    sList : "Documents"
 *	  , xUser : _spPageContextInfo.userId
 *	  , sRole : "Edit"
 * } );
 * @todo provide a full list of roles in documenation
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name or guid of a list
 * @param {String} args.xUser either id or email or login name (osce\\jriemer) of a user
 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
 */
__.SP.list.restrictToUser = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	ctx.load( oList );
	var oUsers = ctx.get_web().get_siteUsers();
	var oUser = null;
	if( ! isNaN( args.xUser ) ) {
		oUser = oUsers.getById( args.xUser );
	}
	else if( args.xUser.__isEmail() ) {
		oUser = oUsers.getByEmail( args.xUser );
	}
	else {
		oUser = oUsers.getByLoginName( args.xUser );
	}
	var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
	var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
	oBinding.add( oRole );
	oList.breakRoleInheritance( false );
	oList.get_roleAssignments().add( oUser, oBinding );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject( oList.sError );
		}
		else {
			async.resolve();
		}
	} );
}


/*
 * get edir rights
    var web,clientContext,currentUser,oList,perMask;

    clientContext = new SP.ClientContext.get_current();
    web = clientContext.get_web();
    currentUser = web.get_currentUser();   
    oList = web.get_lists().getByTitle('Actions');
    clientContext.load(oList,'EffectiveBasePermissions');
    clientContext.load(currentUser); 
    clientContext.load(web);           

    clientContext.executeQueryAsync(function(){
        if (oList.get_effectiveBasePermissions().has(SP.PermissionKind.editListItems)){
            console.log("user has edit permission");
        }else{
             console.log("user doesn't have edit permission");
        }   
    }, function(sender, args){
        console.log('request failed ' + args.get_message() + '\n'+ args.get_stackTrace());
    });


*/
__.Common = {};
__.Common.Urls = {
	aaurl : {
		  prod : {
			rso : 'https://rso.osce.org/',
			docin : 'https://docin.osce.org/',
			sharepoint : 'https://sharepoint.osce.org/',
			mySite : 'https://sp-selfservice.osce.org/',
			midtier : 'https://ws-sharepoint.osce.org/WebService.asmx/',
			sputils : 'https://sputils-ssom.osce.org/'
		}
		, test : {
			rso : 'https://test-rso.osce.org/',
			docin : 'https://test-docin.osce.org/',
			sharepoint : 'https://test-jarvis.osce.org/',
			mySite : 'https://test-sp-selfservice.osce.org/',
			midtier : 'https://test-ws-sharepoint.osce.org/WebService.asmx/',
			sputils : 'https://sputils-ssom-test.osce.org/'
			
		}
		, dev : {
			rso : 'https://dev-rso.osce.org/',
			docin : 'https://dev-docin.osce.org/',
			sharepoint : 'https://dev-sharepoint.osce.org/',
			mySite : 'https://dev-sp-selfservice.osce.org/',
			midtier : 'https://dev-ws-sharepoint.osce.org/WebService.asmx/',
			sputils : 'https://sputils-ssom-dev.osce.org/'
		}
	}
	, get : function( sDomain ) {
		var sEnv = "prod";
		if( /(^test-|-test\.)/.test( self.location.host ) ) {
			sEnv = "test";
		}
		else if( /(^dev-|-dev\.)/.test( self.location.host ) ) {
			sEnv = "dev";
		}
		var url = this.aaurl[ sEnv ][ sDomain ];
		return url;
	}
};
//
//
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.webservice; __.SP.webservice.call;
// ==/ClosureCompiler==


/**
 * @namespace __.SP.webservice
 * @memberof __.SP
 */

__.SP.webservice = {
	/**
	 * Calls a webservice and handles results
	 * @memberof __.SP.webservice
	 * @method call
	 * @example // standalone
	 * __.SP.webservice.call( {
	 * 	  sService : "midtier"
	 * 	, sEndpoint : "SPMySiteListRead"
	 * 	, oPayload : {
	 * 		  listName : "MyBookMarks"
	 * 		, fields : __.o.s( ["Title","Url","LinkType"] )
	 * 	}
	 * 	, cb : function( oResult ) {
	 * 		var msResponse = __.s.o( oResult.oResponse.responseText );
	 * 		console.log( __.s.o( msResponse.d ) );
	 * 	}
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} [args.sService] name of the webservice which is looked up in the O$C3.Url mapping object.
	 * @param {String} [args.sEndpoint] name of the endpoint
	 * @param {String} [args.url] a URl of a web service replacing args.sService/args.sEndpoint combination.
	 * @param {String} [args.sMethod] HTTP method (default is "POST")
	 * @param {Object} [args.oPayload] Object holding parameters as key value pairs 
	 * @param {Object} [args.aHeaders] Object holding custom HTTP headers as key value pairs 
	 * @param {Number} [args.msTimeout] Timeout in millisecons (default is 20 seconds)
	 * @param {Boolean} [args.bIgnoreFailure] Flag to indicate we are not interested in error handling.
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * (resolved) oResponse | (Object) | XMLHTTP response object 
	 * (rejected) sError | (String) | error message
	 * (rejected) [sInfo] | (String) | additional information
	 * </pre>
	 */
	  call : function( args ) {
		var async = __.Async.promise( args );
		var that = this;
		var sPayload = args.oPayload.__toString();
		var sMethod = args.sMethod || "POST";
		var oAjax = window.XMLHttpRequest ?
			new XMLHttpRequest() :
			new ActiveXObject( 'Microsoft.XMLHTTP' );
		var url = args.url || __.Common.Urls.get( args.sService ) + args.sEndpoint + "?";
		oAjax.open( sMethod, url, true );
		oAjax.withCredentials = true;
		oAjax.onreadystatechange = function() {
			var fnerr = function( oAjax, sError ) {
				var sError = "";
				try {
					var oResponse = oAjax.response.__toJson();
					if( oResponse && oResponse.Message ) {
						// check if we get back a JSON with "Message" (EDRMS case)
						sError = oResponse.Message;
						if( oResponse.ID ) {
							sError = "[CODE|" + oResponse.ID + "] " + sError;
						}
					}
					else {
						// then check if we get back any sort of XML/HTML response
						// in which case we try to parse the content
						sError = oAjax.response.replace( /^.*<body+?>/g, "" );
						sError = sError.replace( /<(.|\n)*?>/g, "" );
						sError = sError.trim().substring( 0, 300 );
					}
				} catch( e ) {}
				// if we did not come up with a suitable error message...
				if( ! sError ) {
					// .. we check if the statusText holds any information
					sError = ( oAjax.statusText )
						? "Error reported: " + ( oAjax.statusText )
						// .. as last resort we conclude the connection was aborted
						: "Network connection aborted.";
				}
				if( args.bIgnoreFailure ) {
					async.stop();
				}
				else {
					async.reject( sError );
				}
			};
			if( oAjax.readyState === 4 ) {
				if( oAjax.status == 0 ) {
					fnerr( oAjax, "Could not connect to: " + ( args.sService.toUpperCase() ) );
				}
				else if( oAjax.status < 400  ) {
					async.resolve( { oResponse : oAjax } );
				}
				else if( oAjax.status == 401  ) {
					fnerr( oAjax, "Access denied to: " + ( args.sService.toUpperCase() ) );
				}
				else {
					fnerr( oAjax );
				}
			}
		}
		oAjax.setRequestHeader( "Accept", "application/json" );
		oAjax.setRequestHeader( "Content-Type", "application/json; charset=UTF-8;" );
		oAjax.setRequestHeader( "X-Requested-With", "XMLHttpRequest" );
		// apply custom headers
		if( args.aHeaders ) {
			for( var k in args.aHeaders ) {
				var v = this.aHeaders[ k ];
				oAjax.setRequestHeader( k, v );
			}
		}
		oAjax.timeout = args.msTimeout || 20000;
		oAjax.send( sPayload );
	}
};

// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.item; 
// ==/ClosureCompiler==


/**
 * @namespace __.SP.item
 * @memberof __.SP
 */

__.SP.item = {
	/**
	 * Creates an item in a list with a set of key/value pairs.
	 * NB: The method is incomplete and does not cater for all possible 
	 * field types.
	 * @memberof __.SP.item
	 * @method create
	 * @example
	 * __.SP.item.create( {
	 * 	  sList : "Shared Documents"
	 *	, kv : {
	 *             Title : "new item"
	 *           , Description : "a new item"
	 *      } 
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Array} args.lsFields array of field names to be returned
	 * @param {String} [args.sSite] Url of a site (defaults to current)
	 * @param {String} [args.pathSearch] folder path to start search from
	 * @param {String} [args.xmlQuery] optional CAML query otherwise entire list is returned
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * lkv | (Object) | array of key value pairs
	 * </pre>
	 */
	  create : function( args ) { // sList, kv
		var async = __.Async.promise( args );
		// get context
		var ctx = __.SP.ctx();
		// get list
		var oList = __.SP.list.get( ctx, args.sList );
		var oInfo = new SP.ListItemCreationInformation();
		var oItem = oList.addItem( oInfo );
		// iterate through key/value pair
		for( var k in args.kv ) {
			var v = args.kv[ k ];
			if( typeof v == "object" ) {
				if( v.id ) {
					var o = new SP.FieldLookupValue();
					o.set_lookupId( v.id );
					oItem.set_item( k, o );
				}
			}
			else {
				oItem.set_item( k, v );
			}
		}
		// update the item
		oItem.update();
		// and invoke "load" on context
		ctx.load( oItem );
		// call the helper function handle the request
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve( {
					  oItem : oItem
					, idItem : oItem.get_id()
				} );
			}
		} );
	}
	/**
	 * Updates an item passing on values as a set of key/value pairs.
	 * @memberof __.SP.item
	 * @method update
	 * @example
	 * __.SP.item.update( {
	 * 	  sList : "Shared Documents"
	 * 	  id : 17
	 *	, kv : {
	 *             Title : "new item"
	 *           , Description : "a new item"
	 *      } 
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 * @param {Array} args.kv a key/value pair data object holding values for indicated fields.
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * oItem | (Object) | handle of the updated SP item object
	 * </pre>
	 */
	, update : function( args ) { // sList, id, kv
		var async = __.Async.promise( args );
		// get context
		var ctx = __.SP.ctx();
		// get list
		var oList = __.SP.list.get( ctx, args.sList );
		// get the item by ID
		var oItem = oList.getItemById( args.id );
		// iterate through key/value pair
		for( var k in args.kv ) {
			var v = args.kv[ k ];
			if( typeof v == "object" ) {
				if( v.lookup ) {
					var lo = [];
					v.lookup.forEach( function( id ) {
						var oLookup = new SP.FieldLookupValue();
						oLookup.set_lookupId( id );
						lo.push( oLookup );
					
					} );
					oItem.set_item( k, lo );
				}
				if( v.choice ) {
					oItem.set_item( k, v.choice.join( "," ) );
				}
			}
			else {
				oItem.set_item( k, v );
			}
		}
		// update the item
		oItem.update();
		// and invoke "load" on context
		ctx.load( oItem );
		// call the helper function handle the request
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve( { oItem : oItem } );
			}
		} );
	}
	/**
	 * Reads fields from an item
	 * @memberof __.SP.item
	 * @method read
	 * @example
	 * __.SP.item.read( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 * 	  , lsFields : [ "Title", "CustomField" ]
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 * @param {Array} args.lsFields array for internal field names
	 * <pre class='return-object'>
	 * kv | (Object) | data object of key/value pairs
	 * </pre>
	 */
	, read : function( args ) {
		var async = __.Async.promise( args );
		// get context
		var ctx = __.SP.ctx();
		// get list
		var oList = __.SP.list.get( ctx, args.sList );
		// get item by ID
		var oItem = oList.getItemById( args.id );
		// in case we pass on additional parameters such as custom
		// field names to be fetched we do this in an array and...
		var lsFields = args.lsFields;
		var _args = args.lsFields.__copy();
		if( lsFields ) {
			// construct the arguments list for the 'load' call
			// by preceding the arguments with the item [oItem]
			_args.unshift( oItem );
		}
		else {
			// and we prepare the arguments list with the item only
			_args = [ oItem ];
		}
		// invoke the "load" call in context of context with lsFields list
		ctx.load.apply( ctx, _args );
		// call the helper function handle the request
		__.SP.exec( ctx, oItem, function( oItem ) {
			var convert = function( sField, oField ) {
				var kv = {};
				if( oField.get_termGuid ) {
					kv[ sField ] = oField.get_label();
					kv[ "guid" + sField ] = oField.get_termGuid();
				}
				else if( oField && oField.get_lookupId ) {
					kv[ sField ] = oField.get_lookupValue();
					kv[ "id" + sField ] = oField.get_lookupId();
				}
				else {
					kv[ sField ] = oField;
				}
				return kv;
			}
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				var kv = {};
				lsFields.forEach( function( sField ) {
					var oField = oItem.get_item( sField );
					var _kv = {};
					if( typeof oField != "undefined" ) {
						if( ! oField ) {
							_kv[ sField ] = ""; // null values
						}
						else if( SP.Taxonomy && oField instanceof SP.Taxonomy.TaxonomyFieldValueCollection ) {
							_kv[ sField ] = [];
							var loTaxTerms = oField.getEnumerator();
							while( loTaxTerms.moveNext() ) {
								var oTaxTerm = loTaxTerms.get_current();
								_kv[ sField ].push( convert( sField, oTaxTerm ) );
							}
						}
						else if( oField instanceof Array ) {
							_kv[ sField ] = [];
							oField.forEach( function( o ) {
								_kv[ sField ].push( convert( sField, o ) );
							} );
						}
						else {
							_kv = convert( sField, oField );
						}
					}
					kv.__add( _kv );
				} );
				async.resolve( { oItem : oItem, kv : kv } );
			}
		} );
	}
	/**
	 * Checks if the current user has edit rights on an item.
	 * @memberof __.SP.item
	 * @method isEditable
	 * @example
	 * __.SP.item.create( {
	 *      sList : "Shared Documents"
	 *    , id : 5
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of item
	 * @returns {Object} Resolved promise holding the following values 
	 * <pre class='return-object'>
	 * bEditable | (Boolean) | true if item is editable by the current user
	 * </pre>
	 */
	, isEditable : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		ctx.load( oItem, "EffectiveBasePermissions" );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				var oPermission = oItem.get_effectiveBasePermissions();
				var bEditable = false;
				if( oPermission.has( SP.PermissionKind.editListItems ) ) {
					bEditable = true;
				}
				async.resolve( { bEditable : bEditable } );
			}
		} );
	}
	/**
	 * Breaks the permission inheritance of an item
	 * @memberof __.SP.item
	 * @method breakInheritance
	 * @example
	 * __.SP.item.breakInheritance( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 */
	, breakInheritance : function( args ) { // sList, id
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		oItem.breakRoleInheritance( false );
		ctx.load( oItem );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve();
			}
		} );
	}
	/**
	 * Resets the original permission inheritance of an item
	 * @memberof __.SP.item
	 * @method resetInheritance
	 * @example
	 * __.SP.item.resetInheritance( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 * } );
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 */
	, resetInheritance : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		oItem.resetRoleInheritance();
		ctx.load( oItem );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve();
			}
		} );
	}
	/**
	 * Adds a group with a permission role to an item
	 * @memberof __.SP.item
	 * @method addGroup
	 * @example
	 * __.SP.item.addGroup( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 *	  , sGroup : "Reader Group 42"
	 *	  , sRole : "Read"
	 * } );
	 * @todo provide a full list of roles in documenation
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 * @param {String} args.sGroup name of the group
	 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
	 */
	, addGroup : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		ctx.load( oItem );
		var oGroups = ctx.get_web().get_siteGroups();
		var oGroup = oGroups.getByName( args.sGroup );
		var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
		var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
		oBinding.add( oRole );
		 oItem.get_roleAssignments().add( oGroup, oBinding );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve();
			}
		} );
	}
	/**
	 * Wipes all exising permissions on an item and adds a group with a permission role to it.
	 * @memberof __.SP.item
	 * @method restrictToGroup
	 * @example
	 * __.SP.item.restrictToGroup( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 *	  , sGroup : "Reader Group 42"
	 *	  , sRole : "Read"
	 * } );
	 * @todo provide a full list of roles in documenation
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 * @param {String} args.sGroup name of the group
	 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
	 */
	, restrictToGroup : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		ctx.load( oItem );
		var oGroups = ctx.get_web().get_siteGroups();
		var oGroup = oGroups.getByName( args.sGroup );
		var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
		var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
		oBinding.add( oRole );
		oItem.breakRoleInheritance( false );
		oItem.get_roleAssignments().add( oGroup, oBinding );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve();
			}
		} );
	}
	// __.SP.item.restrictToUser( { sList : "SideBar", id: 22, xUser: _spPageContextInfo.userId, sRole: "Edit"  } ) 
	/**
	 * Wipes all exising permissions on an item and adds a user with a permission role to it.
	 * @memberof __.SP.item
	 * @method restrictToUser
	 * @example
	 * __.SP.item.restrictToUser( {
	 * 	    sList : "Shared Documents"
	 * 	  , id : 17
	 *	  , xUser : _spPageContextInfo.userId
	 *	  , sRole : "Edit"
	 * } );
	 * @todo provide a full list of roles in documenation
	 * @param {Object} args a parameter object holding the following values
	 * @param {String} args.sList name or guid of a list
	 * @param {Number} args.id id of the list item
	 * @param {String} args.xUser either id or email or login name (osce\\jriemer) of a user
	 * @param {String} args.sRole permission role (possible values: Contribute, Read, Edit, Custom Levelname) 
	 */
	, restrictToUser : function( args ) {
		var async = __.Async.promise( args );
		var ctx = __.SP.ctx();
		var oList = __.SP.list.get( ctx, args.sList );
		var oItem = oList.getItemById( args.id );
		ctx.load( oItem );
		var oUsers = ctx.get_web().get_siteUsers();
		var oUser = null;
		if( ! isNaN( args.xUser ) ) {
			oUser = oUsers.getById( args.xUser );
		}
		else if( args.xUser.__isEmail() ) {
			oUser = oUsers.getByEmail( args.xUser );
		}
		else {
			oUser = oUsers.getByLoginName( args.xUser );
		}
		var oBinding = SP.RoleDefinitionBindingCollection.newObject( ctx );
		var oRole = ctx.get_web().get_roleDefinitions().getByName( args.sRole );
		oBinding.add( oRole );
		oItem.breakRoleInheritance( false );
		oItem.get_roleAssignments().add( oUser, oBinding );
		__.SP.exec( ctx, oItem, function( oItem ) {
			if( oItem.sError ) {
				async.reject( oItem.sError );
			}
			else {
				async.resolve();
			}
		} );
	}
};
/**
 * Collection of methods dealing with functionality around list views of SharePoint lists.
 * @namespace __.SP.grid
 * @memberof __.SP
 */

__.SP.grid = {
	/**
	 * Returns item data of the current list view.
	 * Includes only data displayed in the view.
	 * @memberof __.SP.grid
	 * @method oData
	 * @todo rename to aListData or aData
	 * @todo test return example
	 * @example __.SP.grid.oData();
	 * @returns {Object} object of item data arranged by item IDs
	 * Example:
	 * <pre>
	 * {
	 *     11 : { ID : 11, Title : "title 1", Email : "test1@abc.com" }
	 *   , 13 : { ID : 13, Title : "title 2", Email : "test2@abc.com" }
	 * }
	 * </pre>
	 */
	  oData : function() {
		var o = {};
		ctx.ListData.Row.forEach( function( oData ) {
			o[ oData.ID ] = oData;
		} );
		return o;
	}
	/**
	 * Returns DOM node of the list webpart
	 * @memberof __.SP.grid
	 * @method dnWebpart
	 * @example var dnWebpart = __.SP.grid.dnWebpart();
	 * @returns {Node} DOM node of the list webpart
	 */
	, dnWebpart : function() {
		return document.body.__find( "#scriptWPQ2" );
	}
	/**
	 * Returns DOM node of the list webpart's main table
	 * @memberof __.SP.grid
	 * @method dnGrid
	 * @example var dnGrid = __.SP.grid.dnGrid();
	 * @returns {Node} DOM node of the main table
	 */
	, dnGrid : function() {
		return document.body.__find( "table[summary]" );
	}
	/**
	 * Returns item data of the currently selected items.<br>
	 * Includes only data displayed in the view.
	 * @memberof __.SP.grid
	 * @method selection
	 * @todo test return example
	 * @example __.SP.grid.selection();
	 * @returns {Object} object of item data arranged by item IDs
	 * Example:
	 * <pre>
	 * {
	 *     11 : { ID : 11, Title : "title 1", Email : "test1@abc.com" }
	 * }
	 */
	, selection : function() {
		var oData = __.SP.grid.oData();
		var loItems = SP.ListOperation.Selection.getSelectedItems();
		loItems.forEach( function( oItem ) {
			oItem.__add( oData[ oItem.id ] );
		} );
		return loItems;
	}

	/**
	 * Clears current selection of items in list.
	 * @memberof __.SP.grid
	 * @method clearSelection 
	 * @example __.SP.grid.clearSelection();
	 */
	, clearSelection : function() {
		document.body.__find( ".s4-itm-selected", function( dn, ix ) {
			setTimeout( function() {
				dn.__find( ".ms-selectitem-span" ).click();
			}, ix );
		} );
	}

	/**
	 * Locks the list webpart by greying it out and preventing any
	 * user interactions with the list.
	 * @memberof __.SP.grid
	 * @method lock
	 * @example __.SP.grid.lock();
	 */
	, lock : function() {
		var dnWebpart = this.dnWebpart();
		if( dnWebpart ) {
			__.lock.up( dnWebpart );
		}
	}

	/**
	 * Unlocks the webpart enabling user interactions again.
	 * @memberof __.SP.grid
	 * @method unlock
	 * @example __.SP.grid.unlock();
	 */
	, unlock : function() {
		var dnWebpart = this.dnWebpart();
		if( dnWebpart ) {
			__.lock.un( dnWebpart );
		}
	}

	/**
	 * Refreshes the list view without reloading the entire page. 
	 * @memberof __.SP.grid
	 * @method reload
	 * @todo test replacing return false in catch with page reload?
	 * @example __.SP.grid.reload();
	 */
	, reload : function( ms ) {
		ms = ms || 0;
		console.log( ">>>>>>>>>>>" + ms );
		setTimeout( function() {
			var dn = document.body.__find( "#ManualRefresh" );
			if( dn ) {
				dn.click();
			}
			else {
				try {
					var idList = SP.ListOperation.Selection.getSelectedList();
					idList = idList.toLowerCase().replace( "-", "_" ).replace( "{", "" ).replace( "}", "" );
					__doPostBack( "ctl00$m$g_" + idList + "$ctl02", "cancel" );
				} catch( e ) {
					return false;
				}
			}
			return true;
		}, ms );
	}
};

__.SP.icon = {
	mp : {
		  "x32" : {
			  placeholder : "/_layouts/15/images/placeholder32x32.png"
			, approved : "/_layouts/15/images/osce/checkmark.png"
			, approve : "/_layouts/15/images/osce/checkmark.png"
			, publish : "/_layouts/15/images/osce/checkmark.png"
			, rejected : "/_layouts/15/images/osce/x.png"
			, reject : "/_layouts/15/images/osce/x.png"
			, unpublish : "/_layouts/15/images/osce/x.png"
			, cancel : "/_layouts/15/images/osce/cancel.png"
			, close : "/_layouts/15/images/osce/cancel.png"
			, save : "/_layouts/15/images/osce/save.png"
		}
		, "x16" : {
			  folder : "/_layouts/15/images/osce/folder.gif"
			, contact : "/_layouts/15/images/osce/contact.png"
			, danger : "/_layouts/15/images/osce/danger.png"
			, contact : "/_layouts/15/images/osce/contact.png"
			, loading : "/_layouts/15/images/osce/loading.gif"
			, tags : "/_layouts/15/images/EMMCopyTerm.png"
			, calendar : "/_layouts/15/images/calendar_25.gif?rev=23"
		}
		, "x8" : { // evntually 9
			  locked : "/_layouts/15/images/lockoverlay.png"
			, unlocked : "/_layouts/15/images/osce/lockoverlay-green.png"
			, danger : "/_layouts/15/images/osce/danger-small.png"
			, reject : "/_layouts/15/images/osce/danger-small.png"
			, expanded : "/_layouts/15/images/osce/expanded.png"
			, collapsed : "/_layouts/15/images/osce/collapsed.png"
			, blank : "/_layouts/15/images/blank.gif?rev=23"
		}
	}
};
// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @js_externs var __; __.SP; __.SP.form;
// ==/ClosureCompiler==


/**
 * Methods that deal with item add and edit forms
 * @namespace __.SP.form
 * @memberof __.SP
 */

__.SP.form = {};

/**
 * Gets information of a form field by either internal name or any DOM node inside (e.g. to be used in onfocus, onclick events).
 * @memberof __.SP.form
 * @method getField
 * @instance
 * @example
 * __.SP.form.getField( "Title" );
 * @param {String|Node} either internal name or any DOM node inside field row
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * sField | (String) | internal name of the field
 * dnRow | (Node) | DOM node of containing table row (TR)
 * dnValue | (Node) | DOM node of the form element holding user input
 * v | (String) | current value of element holding user input
 * </pre>
 */

__.SP.form.getField = function( s_or_dn ) {
	var dnForm = __find( "#WebPartWPQ2" );
	var url = self.location.href;
	if( /DispForm\.aspx/.test( url ) ) {
		if( typeof s_or_dn == "string" ) {
			var dnTitle = dnForm.__find( 'a[name="SPBookmark_' + s_or_dn + '"]' );
			if( dnTitle ) {
				var dnRow = dnTitle.__closest( "tr" );
				var dnValue = dnRow.__find( "td.ms-formbody" );
				var v = ( dnValue.textContent )
					? dnValue.textContent.__tokenize()
					: null;
				return {
					  dnTitle : dnTitle
					, dnRow : dnRow
					, dnValue : dnValue
					, v : v
				}
			}
			return null;
		}
	}
	else if( /NewForm\.aspx|EditForm\.aspx/.test( url ) ) {
		var dnItem = ( s_or_dn instanceof Element )
			? s_or_dn
			: __find( "#" + s_or_dn );
		if( dnItem ) {
			var dnRow = dnItem.__closest( "tr" );
			var sField = dnRow.__find( "h3" ).id;
			var dnValue = ( dnItem.value ) ? dnItem : dnRow.__find( "input,textarea,select" );
			var v = dnValue.value;
			return {
				  sField : sField
				, dnRow : dnRow
				, dnValue : dnValue
				, v : v
			}
		}
		return null;
	}
};


/**
 * __.SP.Filter creates a new filter panel for a list.
 * <br>By default it is rendered in the left panel next to the list view.
 * <br>The user can perform filter searches, save them as personal views
 * and control visibility of filter fields.
 * @memberof __.SP
 * @class __.SP.Filter
 * @param {Object} args a parameter object holding the following values
 * @property {String} args.sList name of list for which we want to create a filter
 * @param {Array} args.loFields list of field objects {oField} that constitute the filter
 * @property {Function}  [args.cbCreate] callback to be invoked when the filter gets created
 * @property {Function}  [args.cbClear] callback to be invoked when the user clears the filter
 * @property {String}  [args.defaultView] name of the default view
 * @property {Object}  [args.oTax] object holding term store and sets (default is __.SP.taxonomy.oStore)
 * @todo rename defaultView to sdftView;
 * @example n/a
 */
__.SP.filter = {};


__.SP.Filter = __.Class.extend( {
	  dnRoot : null
	, dnForm : null
	, guidFilter : null
	, sList : null
	, cbCreate : null
	, cbDataEntered : null
	, cbClear : null
	, lsFilterFields : null
	, sFilterFieldStore : ""
	, sExpoertFieldStore : ""
	, sFilter : null
	, sFilterName : "Current Filter"
	, sList : null
	, oTax : null
	, dnSideNav : null
	, mpLang : {
		  saved_filter_name_exists_overwrite : "The selected filter name exists already.<br>Do you want to overwrite the existing filter with the current one?"
		, filter_field_selection_title : "Below you can select the fields to be displayed in your filter."
		, export_field_selection_title : "Below you can select the fields to be exported to Excel."
	}
	, init : function( aConf ) {
		var that = this;
		this.sList = aConf.sList;
		this.loAllFields = aConf.loFields;
		this.loFields = this.extractFilterFields( aConf.loFields );
		this.cbCreate = aConf.cbCreate || null;
		this.cbClear = aConf.cbClear || null;
		this.oTax = aConf.oTax || __.SP.taxonomy.oStore;
		this.defaultView = aConf.defaultView || "AllItems";
		// SP's OOTB default views differ in internal and display name
		this.sdftView = aConf.defaultView || "AllItems";
		this.sFilter = "_filter_" + this.sList.__tokenize() + "_";
		this.sFilterFieldStore = this.sFilter + "_filter_";
		this.sExportFieldStore = this.sFilter + "xls_export";
		// check if filter has already been created
		console.log( '>>>' );
		( new __.Async( {
			  id : "__.SP.Filter.init"
			, sdftError : "Failed to initialize a list filter."
		} ) )
		.then( __.SP.filter.form, "loadSPScripts" )
		.then( function( args ) {
			var h = "<div id='"+ that.sFilter +"' style='display:none' class='osce-filter'></div>";
			that.dnSideNav = __find( "#sideNavBox" );
			that.dnRoot = that.dnSideNav.__append( h );
			that.createButtons();
			that.dnForm = __.SP.filter.form.create( {
				  dnRoot : that.dnRoot
				, idFilter : that.sFilter
				, loFields : that.getFields()
				// , cbChange : function() { that.toggleButtons() }
			} );
			if( that.cbCreate ) {
				that.cbCreate( that.dnRoot );
			}
			__.Async.promise( args ).resolve();
		}, "create filter" )
		.then( function( args ) {
			that.getFilterFields();
			that.show();
			__.Event.listen( that, "hashchange" );
			__.Async.promise( args ).resolve();
		}, "show and subscribe to broadcaster" )
		.start();
	}
	, extractFilterFields : function( loFields ) {
		var loFields = loFields.__toString().__toJson().__kSort( "nFilter" );
		var loFilterFields = [];
		loFields.forEach( function( oField ) {
			if( oField.nFilter ) {
				loFilterFields.push( oField );
			}
		} );
		return loFilterFields;
	}
	, lsFormFields : null
	, getFormFields : function() {
		var that = this;
		if( ! this.lsFormFields ) {
			this.lsFormFields = [];
			this.loAllFields.forEach( function( aField ) {
				if( ! aField.bHiddenInForm ) {
					that.lsFormFields.push( aField.sName );
				}
			} );
		}
		return this.lsFormFields;
	}
	, lsListFields : null
	, getListFields : function() {
		var that = this;
		if( ! this.lsListFields ) {
			this.lsListFields = [];
			this.loAllFields.forEach( function( aField ) {
				if( ! aField.bHiddenInList ) {
					that.lsListFields.push( aField.sName );
				}
			} );
		}
		return this.lsListFields;
	}
	, lsExportFields : null
	, getExportFields : function() {
		var that = this;
		var slsExportFields = localStorage.getItem( this.sExportFieldStore );
		if( slsExportFields ) {
			this.lsExportFields = slsExportFields.__toJson();
		}
		if( ! this.lsExportFields ) {
			this.lsExportFields = [];
			this.loAllFields.forEach( function( aField ) {
				if( aField.bExport ) {
					that.lsExportFields.push( aField.sName );
				}
			} );
			localStorage.setItem( this.sExportFieldStore, this.lsExportFields.__toString() );
		}
		return this.lsExportFields;
	}
	, updateExportFields : function( lsFields ) {
		var that = this;
		this.lsExportFields = lsFields;
		localStorage.setItem( this.sExportFieldStore, this.lsExportFields.__toString() );
	}
	, exportView : function( lsFields, dnModal, sView ) {
		var that = this;
		( new __.Async( {
			  id : "__.SP.Filter.exportView"
			, sdftError : "Failed to export a view."
		} ) )
		.then( __.SP.view, "copy", {
			  sList : that.sList
			, sOldView : sView || ctx.viewTitle
			, sNewView : "xls_export"
		}, "copy current view" )
		.clear()
		.then( function( args ) {
			var async = __.Async.promise( args );
			async.then( __.SP.view, "update", {
				  sList : that.sList
				, sView : "xls_export"
				, lsFields : lsFields
			}, "added all fields to view" ).resolve();
		}, "update export view" )
		.then( __.SP.view, "deleteFields", {
			lsFields : [ "js", "DossierFile" ]
		}, "Remove system fields" )
		.then( __.SP.view, "read", "Read guid of export view" )
		.then( function( args ) {
			var url = ctx.HttpRoot + "/_vti_bin/owssvr.dll?CS=109&Using=_layouts/query.iqy";
			url += "&List=" + ctx.listName;
			url += "&View={" + args.kv.guid + "}";
			url += "&CacheControl=1";
			dnModal.close();
			window.open( url );
			__.Async.promise( args ).resolve();
		} )
		.start();
	}
	, onHashchange : function( oMessage ) {
		if( oMessage.sList !== this.sList ) {
			this.hide();
		}
	}
	, unlock : function() {
		__.SP.grid.unlock();
		__.lock.un( this.dnRoot );
	}
	, lock : function() {
		__.SP.grid.lock();
		__.lock.up( this.dnRoot );
	}
	, hide : function() {
		this.dnRoot.style.display = "none";
	}
	, show : function() {
		this.dnRoot.style.display = "block";
		this.update();
	}
	, read : function() {
		var kv = __.SP.filter.form.read( this.getForm() );
		for( var k in kv ) {
			if( ! kv[ k ] ) {
				delete kv[ k ];
			}
		}
		return ( kv.__isEmpty() ) ? null : kv;
	}
	, bFilterView : function() {
		if( ! this.guidFilter ) {
			return false;
		}
		var rx = new RegExp( this.guidFilter );
		return rx.test( self.location.href );
	}
	, bDataEntered : function() {
		var oData = this.read();
		if( this.cbDataEntered ) {
			oData = this.cbDataEntered( oData );
		}
		return !! ( oData );
	}
	, createPersonalViewUrl : function( guid ) {
		var url = _spPageContextInfo.webServerRelativeUrl;
		url += "/_layouts/15/start.aspx#/Lists/" + this.sList + "/";
		url += "PersonalViews.aspx?PageView=Personal&ShowWebPart=";
		url += "{" + guid + "}";
		return url;
	}
	, loadDefaultView : function() {
		var url = _spPageContextInfo.webServerRelativeUrl;
		url += "/_layouts/15/start.aspx#/Lists/" + ctx.ListTitle +"/";
		url += this.defaultView + ".aspx?r=" + Math.random();
		self.location.href = url;
	}
	, loadPersonalView : function( guid ) {
		var bReload = new RegExp( guid, "i" ).test( self.location.href );
		self.location.href = this.createPersonalViewUrl( guid );
		if( bReload ) {
			__.SP.grid.reload( 1000 );
		}
	}
	, form2hash : function() {
		var kv = this.read();
		var sHash = ( kv ) ? "&query=__" + kv.__toString() + "__" : "";
		return sHash;
	}
	, getForm : function() {
		return this.dnForm;
		var id = "_filter_" + ctx.ListTitle.__tokenize() + "_";
		var dnForm = document.body.__find( "#" + id );
		if( dnForm ) {
			return dnForm;
		}
		return null;
	}
	, update : function() {
		__.SP.filter.form.reset( this.dnForm );
		this.unlock();
		this.caml2form();
		this.toggleFilterFields();
	}
	, caml2form : function() {
		var dnForm = this.getForm();
		var that = this;
		if( ! dnForm ) { return }
		var sView = ctx.viewTitle;
		var sList = ctx.ListTitle;
		( new __.Async( {
			  id : "__.SP.Filter.caml2form"
			, sdftError : "Failed to convert search to filter."
		} ) )
		.then( __.SP.view, "read", {
			  sList : ctx.ListTitle
			, sView : sView
		}, "read current view" )
		// REF: extract xml query reading in method for we need parts again further down the code
		.then( function( args ) {
			var async = __.Async.promise( args )
			var xmlQuery = args.kv.xmlQuery;
			lsxml = xmlQuery.match( /<Where>.*?<\/Where>/ );
			if( lsxml && lsxml[ 0 ] ) {
				xmlQuery = lsxml[ 0 ];
				var dn = document.body.__append( xmlQuery );
				dn.__find( "FieldRef", function( dn ) {
					// get necessary attributes from field node
					var sName = dn.getAttribute( "name" );
					var sOperator = dn.parentNode.tagName;
					// create sid of field
					var sid = ( that.sFilter + sOperator + sName ).__tokenize();
					// get the corresponding field in our filter
					var dnField = dnForm.__find( "[sid='" + sid + "']" );
					// skip unknown fields (e.g. for custom queries such as cherry picks)
					if( ! dnField ) {
						return;
					}
					var sFormType = dnField.getAttribute( "sFormType" );
					if( sFormType == "taxonomy" ) {
						async.then( __.SP.taxonomy, "load", {
							  sTermSet : that.oTax.guidTermSet[ sName ]
						}, "load " + sName )
					}
				} );
			}
			async.resolve();
		}, "load taxonomies" )
		.then( __.SP.taxonomy, "getTermIds", {}, "get taxonomy term ids" )
		.then( function( args ) {
			var bTaxTerms = false;
			// REF be more defensiv here
			var xmlQuery = args.kv.xmlQuery;
			lsxml = xmlQuery.match( /<Where>.*?<\/Where>/ );
			if( lsxml && lsxml[ 0 ] ) {
				xmlQuery = lsxml[ 0 ];
				var dn = document.body.__append( xmlQuery );
				dn.__find( "FieldRef", function( dn ) {
					// get necessary attributes from field node
					var sName = dn.getAttribute( "name" );
					var sOperator = dn.parentNode.tagName;
					// create sid of field
					var sid = ( that.sFilter + sOperator + sName ).__tokenize();
					// get the corresponding field in our filter
					var dnField = dnForm.__find( "[sid='" + sid + "']" );
					// skip unknown fields (e.g. for custom queries such as cherry picks)
					if( ! dnField ) {
						return;
					}
					var sFormType = dnField.getAttribute( "sFormType" );
					// and we check its type of field (e.g. choice, taxonomy, etc. )
					// all supported types are found in __.SP.filter.form.js
					var dnMultiValues = dn.__find( "values" );
					if( dnMultiValues ) {
						dn = dnMultiValues;
					}
					// get the last entry for we only have multiple values in case of
					// taxonomies and there we put the parent term at the end.
					if( dn && dn.lastChild && dn.lastChild.textContent ) {
						var v = dn.lastChild.textContent;
						// get the name of the term if it had not been assigned yet, hence
						// its ID was set to -1 see other comment in __.SP.caml.js
						var sTermNotAssignedYet = dn.lastChild.getAttribute( "stermnotassignedyet" );
						if( sFormType == "taxonomy" ) {
							bTaxTerms = true;
							// check if we deal with the name of the tag
							// this happens if we ddidn't had the term id when querying
							if( sTermNotAssignedYet ) {
								sTermNotAssignedYet = unescape( sTermNotAssignedYet );
								var oTax = __.SP.taxonomy.aTerms[ that.oTax.guidTermSet[ sName ] ];
								var aTermsLookup = oTax.aTerms;
								var guidTerm = aTermsLookup[ sTermNotAssignedYet ].guid;
								v = {
									  guid : guidTerm
									, sName : sTermNotAssignedYet
								}
							}
							else {
								v = __.SP.taxonomy.termInfo( parseInt( v ) );
							}
						}
						if( sFormType == "checkbox" ) {
							if( v !== "" ) {
								v = ( v == 1 ) ? "Yes" : "No";
							}
						}
						if( v ) {
							__.SP.filter.form.field[ sFormType ].set( dnField, v );
						}
					}
				} );
				// in case we deal with tax terms we need to check if
				// the query changed in the meanwhile.
				if( bTaxTerms ) {
					that.compareQueries();
				}
				dn.__remove();
			}
			__.Async.promise( args ).resolve();
		}, "Analyse query" )
		.start();
	}
	, form2caml : function() {
		var that = this;
		var oFields = this.read();
		var lvCAML = [];
		if( oFields ) {
			var idFilter = this.getForm().id;
			for( var sid in oFields ) {
				var oField = oFields[ sid ];
				var v = oField.v;
				if( v ) {
					switch( oField.sCAMLType ) { // boolean, taxonomy, text, lookup, choice
						case "text" :
						case "date" : // REF check date on own property
						case "choice" :
						case "lookup" :
							lvCAML.push( {
								  sName : oField.sName
								, sType : oField.sCAMLType
								, sOperator : oField.sOperator
								, v : v
							} );
						break;
						case "boolean" :
							v = ( v == "Yes" ) ? 1 : 0;
							lvCAML.push( {
								  sName : oField.sName
								, sType : oField.sCAMLType
								, sOperator : oField.sOperator
								, v : v
							} );
						break;
						case "taxonomy" :
							laTaxFields = [];
							var idTermSet = that.oTax.guidTermSet[ oField.sName ];
							for( var sName in v ) {
								// first get guids of children terms
								var guid = v[ sName ];
								var lguid = __.SP.taxonomy.children( {
									  idParent : guid
									, idTermSet : idTermSet
								} );
								// then lookup those term's IDs
								var lid = [];
								lguid.forEach( function( guid ) {
									var aTermInfo = __.SP.taxonomy.termInfo( guid );
									if( aTermInfo ) {
										lid.push( {
											  id : aTermInfo.id
											, sName : aTermInfo.sName
										} );
									}
								} );
								// also search add the parent term, if it does not
								// exist we set to -1 otherwise the id list might be
								// completely empty resulting in no restrictions
								var aTermInfo = __.SP.taxonomy.termInfo( guid );
								var idParent = ( aTermInfo ) ? aTermInfo.id : -1;
								lid.push( {
									  id : idParent
									, sName : sName
								} );
								if( ! lid.__isEmpty() ) {
									laTaxFields.push( lid );
								}
							}
							if( ! laTaxFields.__isEmpty() ) {
								lvCAML.push( {
									  sType : "taxonomy"
									, sName : oField.sName
									, v : laTaxFields
								} );
							}
						break;
					}
				}
			}
			var lxml = __.SP.caml.createFields( lvCAML );
			var xmlQuery = __.SP.caml.whereClause( lxml );
			return xmlQuery;
		}
	}
	, bCompared : null
	, compareQueries : function() {
		var that = this;
		if( this.bCompared ) {
			this.bCompared = null;
			return;
		}
		var sView = ctx.viewTitle;
		// no comparing in current filter
		if( sView == this.sFilterName ) {
			return;
		}
		// no comparing for default views
		if( ! /PersonalViews\.aspx/.test( self.location.hash ) ) {
			return;
		}
		( new __.Async( {
			  id : "__.SP.Filter.compareQueries"
			, sdftError : "Failed to check if search result has been updated."
		} ) )
		.then( __.SP.taxonomy, "getTermIds", "get taxonomy term ids" )
		.clear()
		.then( __.SP.view, "read", {
			  sList : that.sList
			, sView : sView
		}, "read current view query" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			var oFields = that.read();
			for( var sField in oFields ) {
				var oField = oFields[ sField ];
				if( oField.v && oField.sCAMLType == "taxonomy" ) {
					async.then( __.SP.taxonomy, "load", {
						  sTermSet : that.oTax.guidTermSet[ oField.sName ]
					}, "load " + oField.sName )
				}
			}
			async.resolve();
		}, "load taxonomies" )
		.then( function( args ) {
			var token = function( s ) {
				s = s.__tokenize();
				var sValues = s.replace( /<(?:.|\n)*?>/gm, "|" );
				if( sValues ) {
					var lsValues = sValues.split( "|" );
					if( lsValues && lsValues.length > 0 ) {
						lsValues.sort();
						return lsValues.join( "|" );
					}
				}
				return null;
			};
			var async = __.Async.promise( args );
			var newQuery = that.form2caml();
			var ls = args.kv.xmlQuery.match( /<Where>.*<\/Where>/ )
			var oldQuery = ls[ 0 ];
			if( token( newQuery ) != token( oldQuery ) ) {
				async.then( __.SP.view, "update", {
					  sList : that.sList
					, sView : sView
					, xmlQuery : newQuery
				}, "update view" )
				.then( function( args ) {
					that.bCompared = true;
					__.SP.grid.reload();
				}, "reload view" )
			}
			else {
				// query up to date
			}
			async.resolve();
		}, "compare queries" )
		.then( function( args ) {
			__.Async.promise( args ).resolve();
		}, "done" )
		.start();
	}
	, createButtons : function() {
		var that = this;
		var h = "";
		h += "<div id='osce-filter-buttons'>";
		h += '<span class="menu icon-gear" action="gear" title="Manage filter fields"></span>';
		h += '<span class="menu icon-search" action="search" title="Search with this filter"></span>';
		h += '<span class="menu icon-save" action="save" title="Save this search"></span>';
		h += '<span class="menu icon-excel" action="export" title="Export this search"></span>';
		h += '<b><span class="menu icon-clear" action="clear" title="Clear the filter"></span></b>';
		h += "</div>";
		this.dnRoot.__append( h )
			.addEventListener( "click", function( e ) {
				e.preventDefault();
				e.stopPropagation();
				switch( e.target.getAttribute( "action" ) ) {
					case "gear" :
						that.openFilterFieldWindow();
					break;
					case "export" :
						that.openExportFieldWindow();
					break;
					case "search" :
						that.filter();
					break;
					case "clear" :
						__.SP.filter.form.reset( that.dnForm );
						if( that.cbClear ) {
							that.cbClear();
						}
						that.loadDefaultView();
					break;
					case "save" :
						that.openSaveWindow();
					break;
				}
			} );
	}
	, getFields : function() {
		this.loFields.forEach( function( oField ) {
			if( ! oField.sOperator ) {
				oField.sOperator = ( oField.sCAMLType == "taxonomy" ) ? "In" : "Eq";
			}
		} );
		this.loFields = this.loFields.__kSort( "nFilter" );
		return this.loFields;
	}
	, createView : function( sName, cbfn ) {
		var that = this;
		var xmlQuery = '<OrderBy><FieldRef Name="Title" /></OrderBy>';
		( new __.Async( {
			  id : "__.SP.Filter.createView"
			, sdftError : "Failed to create a new filter view."
		} ) )
		.then( __.SP.taxonomy, "getTermIds", "get taxonomy term ids" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			var oFields = that.read();
			for( var sField in oFields ) {
				var oField = oFields[ sField ];
				if( oField.v && oField.sCAMLType == "taxonomy" ) {
					async.then( __.SP.taxonomy, "load", {
						  sTermSet : that.oTax.guidTermSet[ oField.sName ]
					}, "load " + oField.sName )
				}
			}
			async.resolve();
		}, "load taxonomies" )
		.then( function( args ) {
			xmlQuery += that.form2caml();
			__.Async.promise( args ).resolve();
		}, "construct query" )
		.clear()
		.then( __.SP.view, "list", {
			  sList : that.sList
		}, "get list of views" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			var sMode = ( args.lsViews.__contains( sName ) ) ? "update" : "add";
			async.resolve( { sMode : sMode } );
		}, "decide wether to create or update" )
		.then( __.SP.view, "read", {
			  sList : that.sList
			, sView : ctx.viewTitle
		}, "read current view" )
		.then( function( args ) {
			var xml = args.kv.xmlQuery;
			var xmlGroup = "";
			var xmlSort = "";
			var lsParts = xml.match( /(<GroupBy.*?<\/GroupBy>)/ );
			if( lsParts && lsParts.length ) {
				xmlGroup = lsParts[ 1 ];
			}
			var lsParts = xml.match( /(<SortBy.*?<\/SortBy>)/ );
			if( lsParts && lsParts.length ) {
				xmlSort = lsParts[ 1 ];
			}
			xmlQuery = xmlQuery + xmlGroup + xmlSort;
			__.Async.promise( args ).resolve();
		}, "extract grouping and sorting" )
		.then( function( args ) {
			var async = __.Async.promise( args );
			switch( args.sMode ) {
				case "add" :
					async.then( __.SP.view, "add", {
						  sList : that.sList
						, sView : sName
						, xmlQuery : xmlQuery
						, nRows : args.kv.nRows
						, bPaging : args.kv.bPaging
						, sTotal : args.kv.sTotal
						, lsFields : args.kv.lsFields
						, bPublic : false
					}, "add personal view" )
				break;
				case "update" :
					async.then( __.SP.view, "update", {
						  sList : that.sList
						, sView : sName
						, xmlQuery : xmlQuery
						, nRows : args.kv.nRows
						, bPaging : args.kv.bPaging
						, sTotal : args.kv.sTotal
						, lsFields : args.kv.lsFields
						, bPublic : false
					}, "update personal view" )
				break;
			}
			async.resolve();
		}, "add or update view" )
		.then( __.SP.view, "read", "read view for guid" )
		.then( function( args ) {
			cbfn( args.kv.guid );
			__.Async.promise( args ).resolve();
		}, "invoke callback" )
		.start();
	}
	, filter : function() {
		var that = this;
		var sView = that.sFilterName;
		this.lock();
		this.createView( sView, function( guid ) {
			that.guidFilter = guid;
			that.loadPersonalView( guid );
		} );
	}
	// CALLBACK for sidebar?
	, save : function( sView ) {
		var that = this;
		this.createView( sView, function( guid ) {
			var url = that.createPersonalViewUrl( guid );
			self.location.href = url;
		} );
	}
	, openSaveWindow : function() {
		var that = this;
		var h = "<p>";
		h += "You can save the current search as list view. This enables you export the entire search";
		h += " result to Excel.</p>";
		h += "<p>Please enter a name for this new view:</p>";
		h += "<p>";
		h += "<input maxlength='50' type='text' name='sName' style='width:300px;font-size:1.3em;'/>";
		h += "<br><em class='maxlength' style='float:left'>(max. 50 characters)</em>";
		h += "<br></p>";
		this.oModal = __.SP.modal.open( {
			  sTitle : "Save Search as View"
			, hContent : h
			, fnok : function() {
				alert( "OK" );
			}
			, fnerr : function() {
				alert( "err" );
			}
			, fnact : function() {
				that.oModal.message( "" );
				var dnValue = that.oModal.dn.__find( "[name='sName']" );
				var sName = dnValue.value.__sanitize();
				if( sName  ) {
					( new __.Async( {
						  id : "__.SP.Filter.openSaveWindow"
						, sdftError : "Failed to save a filter."
					} ) )
					.then( __.SP.view, "list", {
						  sList : that.sList
					}, "get list of views" )
					.then( function( args ) {
						var async = __.Async.promise( args );
						if( args.lsViews.__contains( sName ) ) {
							var d = __.SP.modal.confirm( {
								  sTitle : "Confirm this action"
								, sQuestion : that.mpLang.saved_filter_name_exists_overwrite
								, fnAnswer : function( b ) {
									that.oModal.close();
									if( b ) {
										that.save( sName );
									}
								}
							} );
						}
						else {
							that.oModal.close();
							that.save( sName );
						}
						async.resolve();
					}, "check if view already exists" )
					.start();
				}
				else {
					// REF: do we overwrite the loading gif here? i.e. after entering name no loading gif?
					that.oModal.message( "Please enter a name" );
				}
			}
		} );
	}
	, openFilterFieldWindow : function() {
		var that = this;
		// first get all filter fields
		var sChecked = " checked ";
		var h = "<p>";
		h += that.mpLang.filter_field_selection_title;
		h += "</p>";
		h += "<table>";
		this.loFields.forEach( function( aField ) {
			if( aField.nFilter ) {
				var sDisabled = ( aField.sName == "FrontOffice" )
					? " disabled "
					: "";
				var sChecked = ( that.lsFilterFields.__contains( aField.sName ) )
					? " checked "
					: "";
				h += "<tr>";
				h += "<td><input name='" + aField.sName + "'type='checkbox' ";
				h += sChecked + sDisabled + "'></input></td>";
				h += "<td title='" + aField.sDescription + "'>";
				h += aField.sDisplayName + " (" + aField.sFO + ")</td>";
				h += "</tr>";
			}
		} );
		h += "</table>";
		var dnModal = __.SP.modal.open( {
			  sTitle : "Manage filter fields"
			, hContent : h
			, fnact : function( oModal ) {
				that.updateFilterFields( oModal );
				dnModal.close();
				that.update();
			}
		} );
	}
	// sView is optional, default is the current list view
	// we use it for e.g. cherry picks in ConMan

	, openExportFieldWindow : function( sView ) {
		var that = this;
		// first get all filter fields
		var sChecked = " checked ";
		var h = "<p>";
		h += that.mpLang.export_field_selection_title;
		h += "</p>";
		h += "<table>";
		this.getExportFields();
		var ix = 0;
		var lhLeftTD = [];
		var lhRightTD= [];
		var cFields = 0;
		this.loAllFields.forEach( function( aField ) {
			if( aField.bExport ) {
				cFields++;
			}
		} );
		var nBreak = Math.round( cFields / 2 );
		var c = 0;
		h += "<table>";
		this.loAllFields.forEach( function( aField ) {
			if( aField.bExport ) {
				var sDisabled = ( aField.sName == "FrontOffice" )
					? " disabled "
					: "";
				var sChecked = ( that.lsFilterFields.__contains( aField.sName ) )
					? " checked "
					: "";
				var hTD = "<td><input name='" + aField.sName + "'type='checkbox' ";
				hTD += sChecked + sDisabled + "'></input></td>";
				hTD += "<td title='" + aField.sDescription + "'>";
				hTD += aField.sDisplayName + "</td>";
				if( c++ < nBreak ) {
					lhLeftTD.push( hTD );
				}
				else {
					lhRightTD.push( hTD );
				}
			}
		} );
		lhLeftTD.forEach( function( hLeftTD, ix ) {
			h += "<tr>";
			h += hLeftTD;
			h += ( lhRightTD[ ix ] ) ? lhRightTD[ ix ] : "<td></td>";
			h += "</tr>";
			
		} );
		h += "</table>";
		var dnModal = __.SP.modal.open( {
			  sTitle : "Export to Excel"
			, hContent : h
			, fnact : function( oModal ) {
				dnModal.message( "" );
				var ldnFields = oModal.dn.__find( "[name]:checked" );
				if( ldnFields ) {
					var lsFields = [];
					ldnFields.__each( function( dn ) {
						lsFields.push( dn.getAttribute( "name" ) );
					} );
					that.updateExportFields( lsFields );
					that.exportView( lsFields, dnModal, sView );
				}
				else {
					dnModal.message( "Please select at least one field." );
				}
			}
		} );
	}
	, toggleFilterFields : function() {
		var that = this;
		this.dnRoot.__find( ".osce-form-field", function( dn ) {
			var sid = dn.getAttribute( "sName" );
			if( that.lsFilterFields.__contains( sid ) ) {
				dn.classList.remove( "hide" );
			}
			else {
				dn.classList.add( "hide" );
			}
		} );
	}
	, getFilterFields : function() {
		var that = this;
		var slsFilterFields = localStorage.getItem( this.sFilterFieldStore );
		if( ! slsFilterFields ) {
			// load default values
			this.lsFilterFields = [];
			this.loFields.forEach( function( oField ) {
				that.lsFilterFields.push( oField.sName );
			} );
			localStorage.setItem( this.sFilterFieldStore, this.lsFilterFields.__toString() );
		}
		else {
			// otherwise use local storage
			this.lsFilterFields = slsFilterFields.__toJson();
		}
	}
	, updateFilterFields : function( oModal ) {
		var that = this;
		this.lsFilterFields = [];
		oModal.dn.__find( "[name]", function( dn ) {
			if( dn.checked ) {
				that.lsFilterFields.push( dn.getAttribute( "name" ) );
			}
		} );
		localStorage.setItem( this.sFilterFieldStore, this.lsFilterFields.__toString() );
	}
} );




__.SP.filter.form = {};

__.SP.filter.form.loadSPScripts = function( args ) {
	var async = __.Async.promise( args );
	var hdTimeout = setTimeout( function() {
		async.reject( "Could not load date library from SharePoint" );
	}, 10000 );
	SP.SOD.executeFunc('SP.js', 'SP.ClientContext', function() {
		SP.SOD.executeFunc( 'datepicker.js', 'clickDatePicker ', function() {
			clearTimeout( hdTimeout );
			async.resolve();
		} )
	} )
};


__.SP.filter.form.create = function( args ) {
	var h = "<form class='osce-form'></form>";
	var dn = args.dnRoot.__append( h );
	args.loFields.forEach( function( oField ) {
		oField.dnRoot = dn;
		oField.idFilter = args.idFilter;
		__.SP.filter.form.field[ oField.sFormType ].create( oField );
	} );
	dn.addEventListener( "change", function() {
		if( args.cbChange ) {
			args.cbChange();
		}
	} );
	var fnModal = function() {
		var dn = document.body.__find( ".ms-dlgContent" );
		if( ! dn ) {
			if( args.cbChange ) {
				args.cbChange();
			}
		}
		else {
			setTimeout( fnModal, 500 );
		}
	}
	dn.addEventListener( "click", function( e ) {
		// monitor closing of taxonomy modal
		if( e.target.classList.contains( "ms-taxonomy-browser-button" ) ) {
			setTimeout( fnModal, 500 );
		}
		// prevent manual manipulation of the taxonomy picker DIV
		if( e.target.classList.contains( "ms-inputBox" ) ) {
			//var dnRoot = e.target.__closest( ".osce-form-field" );
			//var dnImg = dnRoot.__find( "img.ms-taxonomy-browser-button" );
			//dnImg.click();
		}
	} );
	return dn;
};

__.SP.filter.form.reset = function( dn ) {
	// clear all taxonomy fields
	dn.__find( '[role="textbox"]', function( dn ) {
		dn.innerHTML = "";
	} );
	dn.__find( '.osce-v', function( dn ) {
		dn.value = "";
	} );
	// and reset the form
	dn.reset();
};

__.SP.filter.form.read = function( dn ) {
	var kv = {};
	dn.__find( ".osce-form-field", function( dn ) {
		var sid = dn.getAttribute( "sid" );
		var sFormType = dn.getAttribute( "sFormType" );
		kv[ sid ] = {
			  v : __.SP.filter.form.field[ sFormType ].get( dn )
			, sName : dn.getAttribute( "sName" )
			, sCAMLType : dn.getAttribute( "sCAMLType" )
			, sOperator : dn.getAttribute( "sOperator" ) || null
		}
	} )
	return kv;
};

__.SP.filter.form.field = {};


__.SP.filter.form.field.sid = function( x ) {
	// we need unique ids, sName might be used mulitple times,
	// e.g. from/to date fields
	var sid = "";
	if( x instanceof Element ) {
		sid += x.__find( ".osce-filter" ).id;
		sid += ( x.getAttribute( "sOperator" ) + x.getAttribute( "sName" ) ).__tokenize();
	}
	else if( x.idFilter && x.sDisplayName ) {
		sid += x.idFilter;
		sid += ( x.sOperator + x.sName ).__tokenize();
	}
	else {
		console.warn( "parameter is no filter form argument", x );
		return null;
	}
	return sid;
};

__.SP.filter.form.field.hHeader = function( args ) {
	var cssHalfSize = ( args.bHalfSize ) ? " half-size" : "";
	var h = "<div class='osce-form-field" + cssHalfSize + "' ";
	h += ( args.sOperator ) ? " sOperator='" + args.sOperator + "' " : "";
	h += " sFormType='" + args.sFormType + "'";
	h += " sCAMLType='" + args.sCAMLType + "'";
	h += " sName='" + args.sName + "'";
	h += " sid='" + __.SP.filter.form.field.sid( args ) + "'>";
	h += "<label>" + args.sDisplayName + "</label><br />";
	return h;
};

__.SP.filter.form.field.text = {
	  create : function( args ) { //  dnRoot, sid, sDisplayName ) {
		var h = __.SP.filter.form.field.hHeader( args );
		h += "<input class='osce-v'></input>";
		h += "</div>";
		args.dnRoot.__append( h );
	}
	, get : function( dn ) {
		var v = dn.__find( ".osce-v" ).value;
		return ( v ) ? v : null;
	}
	, set : function( dn, v ) {
		var v = dn.__find( ".osce-v" ).value = v;
	}
};

__.SP.filter.form.field.lookupdate = {
	  create : function( args ) { //  dnRoot, sid, sDisplayName ) {
		var sid = __.SP.filter.form.field.sid( args );
		var h = __.SP.filter.form.field.hHeader( args );
		h += "<input id='" + sid + "' class='osce-v date' maxlength='45'></input>";
		h += '<a href="#" role="button" onclick="clickDatePicker( ';
		h += "'" + sid + "'";
		h += ", '" + _spPageContextInfo.siteServerRelativeUrl;
		h += "/_layouts/15/iframe.aspx?cal=1&amp;lcid=2057&amp;langid=1033&amp;tz=00:59:59.9990041&amp;ww=0111110&amp;fdow=1&amp;fwoy=0&amp;hj=0&amp;swn=false&amp;minjday=109207&amp;maxjday=2666269&amp;date='";
		h += ', \'\', event); return false;">';
		h += '<img id="' + sid + 'DatePickerImage" src="' + __.SP.icon.mp.x16.calendar + '"';
		h += ' border="0" class="osce-sp-calendar" alt="Select a date from the calendar.">';
		h += '</a>';
		h += '<iframe id="' + sid + 'DatePickerFrame" src="' + __.SP.icon.mp.x8.blank + '" ';
		h += ' frameborder="0" scrolling="no" style="display:none; position:absolute; width:200px; z-index:101;" ';
		h += ' title="Select a date from the calendar."></iframe>';
		h += "</div>";
		args.dnRoot.__append( h );
	}
	, get : function( dn ) {
		var v = dn.__find( ".osce-v" ).value;
		if( v ) {
			var nDate = v.split( "/" ).reverse().join( "" );;
			return nDate;
		}
		return null;
	}
	, set : function( dn, v ) {
		if( v ) {
			var lsMatch = v.match( /(....)(..)(..)/ );
			var sDate = lsMatch[ 3 ] + "/" + lsMatch[ 2 ] + "/" + lsMatch[ 1 ];
			dn.__find( ".osce-v" ).value = sDate;
		}
	}
};


__.SP.filter.form.field.autocomplete = {
	  create : function( args ) { //  dnRoot, sid, sDisplayName ) {
		var h = __.SP.filter.form.field.hHeader( args );
		h += "<input class='osce-v'></input>";
		h += "</div>";
		var fnFetch = function( sTerm, cbfn ) {
			var xmlQuery = "<Query><Where><Contains>"
			xmlQuery += "<FieldRef Name='" + args.sLookupField + "' />";
			xmlQuery += "<Value Type='Text'>" + sTerm +"</Value>";
			xmlQuery += "</Contains></Where></Query>";
			xmlQuery += "<RowLimit>" + ( args.nLimit || 10 ) + "</RowLimit>";
			( new __.Async( {
				  id : "__.SP.filter.form.field.autocomplete.create"
				, sdftError : "Failed to create an autocomplete field"
			} ) )
			.then( __.SP.list, "read", {
				  sList : args.sLookupList
				, lsFields : [ args.sLookupField ]
				, xmlQuery : xmlQuery
			}, "read lookup list for form filter" )
			.then( function( args ) {
				if( cbfn ) {
					cbfn( args.lkv );
				}
				__.Async.promise( args ).resolve();
			} )
			.start();
		};
		var dnLookup = args.dnRoot.__append( h );
		__.autocomplete.init( {
			  dn : dnLookup.__find( "input" )
			, sField : args.sLookupField
			, fnFetch : fnFetch
			, cb : function( rec ) {
				//
			}
		} );
	}
	, get : function( dn ) {
		var v = dn.__find( ".osce-v" ).value;
		return ( v ) ? v : null;
	}
	, set : function( dn, v ) {
		var v = dn.__find( ".osce-v" ).value = v;
	}
};

// __.SP.filter.form.field.checkbox.create( { dnRoot : __.dn_( "#sideNavBox" ), sid: "qwer", sDisplayName : "a checkbox field" } )
// __.SP.filter.form.field.checkbox.value( "qwer" );
__.SP.filter.form.field.checkbox = {
	  create : function( args ) { // dnRoot, sid, sDisplayName ) {
		var h = __.SP.filter.form.field.hHeader( args );
		h += "<select class='osce-v'>";
			h += "<option value=''></option>";
			h += "<option value='Yes'>Yes</option>";
			h += "<option value='No'>No</option>";
		h += "</select>";
		h += "</div>";
		args.dnRoot.__append( h );
	}
	, get : function( dn ) {
		var v = dn.__find( ".osce-v" ).value;
		return ( v ) ? v : null;
	}
	, set : function( dn, v ) {
		var v = dn.__find( ".osce-v" ).value = v;
	}
};

// __.SP.filter.form.field.choice.create( { dnRoot : __.dn_( "#sideNavBox" ), sid: "test", sDisplayName : "a choice field", lsChoices : [ "asdf", "qwer" ] } )
// __.SP.filter.form.field.taxonomy.value( "test" );
__.SP.filter.form.field.choice = {
	  create : function( args ) { //  dnRoot, sid, sDisplayName, lsChoices ) {
		var h = __.SP.filter.form.field.hHeader( args );
		h += "<select class='osce-v'>";
		h += "<option value=''></option>";
		args.lsChoices.forEach( function( s ) {
			h += "<option value='" + s + "'>" + s + "</option>";
		} );
		h += "</select>";
		h += "</div>";
		args.dnRoot.__append( h );
	}
	, get : function( dn ) {
		var v = dn.__find( ".osce-v" ).value;
		return ( v ) ? v : null;
	}
	, set : function( dn, v ) {
		var v = dn.__find( ".osce-v" ).value = v;
	}
};

// need to load the following in masterpage: sp.Taxonomy.js, scriptforwebtaggingui.js
// __.SP.filter.form.field.taxonomy.create( { dnRoot : __.dn_( "#sideNavBox" ), sid : "MainCat", sDisplayName : "Main Contact Type", idTermSet : __.SP.taxonomy.oStore.guidTermSet.MainContactType} );
// __.SP.filter.form.field.taxonomy.value( "MainCat" );
__.SP.filter.form.field.taxonomy = {
	  create : function( args ) { // dnRoot, sid, sDisplayName, idTermSet ) {
		var sid = __.SP.filter.form.field.sid( args );
		var sidPicker = sid + "_picker";
		var sidInput = sid + "_input";
		var h = __.SP.filter.form.field.hHeader( args );
		h += '<input class="osce-v" name="' + sidInput + '" type="hidden" ';
		h += ' id="' + sidInput + '"></input>';
		h += '<div id="' + sidPicker + '" class="ms-taxonomy">';
		h += '</div>';
		h += "</div>";
		var dn = args.dnRoot.__append( h );
		var sspId = __.SP.taxonomy.oStore.guidTermStore;
		var url = _spPageContextInfo.webServerRelativeUrl;
		url += '\u002f_vti_bin\u002fTaxonomyInternalService.json';
		var dnPicker = document.body.__find( "#" + sidPicker );
		dnPicker.InputFieldId = sidInput;
		dnPicker.SspId = sspId;
		  // REF: put Tax object into __.SP.taxonomy!!!
		dnPicker.TermSetId = __.SP.taxonomy.oStore.guidTermSet[ args.sName ];
		dnPicker.AnchorId = '00000000-0000-0000-0000-000000000000';
		dnPicker.IsMulti = true;
		dnPicker.AllowFillIn = false;
		dnPicker.IsSpanTermSets = false;
		dnPicker.IsSpanTermStores = false;
		dnPicker.IsIgnoreFormatting = false;
		dnPicker.IsIncludeDeprecated = false;
		dnPicker.IsIncludeUnavailable = false;
		dnPicker.IsIncludeTermSetName = false;
		dnPicker.IsAddTerms = false;
		dnPicker.IsIncludePathData = false;
		dnPicker.IsUseCommaAsDelimiter = false;
		dnPicker.Disable = false;
		dnPicker.ExcludeKeyword = false;
		dnPicker.JavascriptOnValidation = "";
		dnPicker.DisplayPickerButton = true;
		dnPicker.Lcid = 1033;
		dnPicker.FieldName = '';
		dnPicker.FieldId = '00000000-0000-0000-0000-000000000000';
		dnPicker.WebServiceUrl = url;
		Microsoft.SharePoint.Taxonomy.ScriptForWebTaggingUI.resetEventsRegistered();
		Microsoft.SharePoint.Taxonomy.ScriptForWebTaggingUI.onLoad( sidPicker );
	}
	, get : function( dn ) {
		var lv = dn.__find( '.osce-v' ).value.trim().split( ";" );
		var kv = {};
		lv.forEach( function( s ) {
			if( s ) {
				var ls = s.split( "|" );
				kv[ ls[ 0 ] ] = ls[ 1 ];
			}
		} );
		return ( kv.__isEmpty() ) ? null : kv;
	}
	, set : function( dn, aTermInfos ) {
		var sName = aTermInfos.sName
		var guid = aTermInfos.guid;
		if( sName && guid ) {
			var dnDisplay = dn.__find( "[role='textbox']" );
			dnDisplay.innerHTML += "<span class='valid-text' title='" + sName + "'>" + sName + "</span>;&nbsp;";
			var dnHidden = dn.__find( "input" );
			var vnew = sName + "|" + guid;
			var lsvHidden = [];
			if( dnHidden.value ) {
				lsvHidden = dnHidden.value.split( ";" );
			}
			lsvHidden.push( vnew );
			dnHidden.value = lsvHidden.join( ";" );
		}
		else {
			console.warn( "warn: invalid term info", sTerm );
		}
	}
}; 






/**
 * @namespace __.SP.ribbon
 * @memberof __.SP
 */

__.SP.ribbon = {};

/**
 * Reloads the current ribbon, refreshing their active states. In case it fails to reload the ribbon it reloads the page
 * @memberof __.SP.ribbon
 * @method reload
 * @instance
 * @example
 * __.SP.ribbon.reload();
 */
__.SP.ribbon.reload = function() {
	try {
		SP.Ribbon.PageManager.get_instance().get_ribbon().refresh();
	} catch( e ) {
		self.location.reload();
	}
};

/**
 * Creates a new icon in a ribbon
 * @memberof __.SP.ribbon
 * @method addIcon
 * @async 
 * @instance
 * @example
 * // not working!
 * __.SP.ribbon.addIcon( {
 * 	  sList : "OSCE Contacts"
 * 	, sRibbon : "CommandUI.Ribbon.ListForm.Edit"//.Edit-title"
 * 	, sSegment : "Ribbon.ListForm.Edit.Commit"
 * 	, sLabel : "hi mom"
 * 	, sAction : "javascript:alert(1)"
 * } )
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sList name of the list 
 * @param {String} args.sRibbon name of the list's ribbon 
 * @param {String} args.sSegment name of the ribbon's segement 
 * @param {String} args.sLabel label of the icon
 * @param {String} args.sDescription description of the icon
 * @param {String} args.sAction inline JavaScript of the onclick action
 * @param {String} args.sEnabled inline JavaScript to identify whether icon is acitve
 * @param {String} args.urlIcon16 URL of the small icon image
 * @param {String} args.urlIcon32 URL of the large icon image
 * @param {String} args.sToolTipTitle title of the tooltip
 * @param {String} args.sToolTipDescription description of the tooltip
 * @note list of list's ribbons: https://msdn.microsoft.com/en-us/library/office/bb802730.aspx
 * @note list of ribbon's segments: https://msdn.microsoft.com/en-us/library/ee537543(office.14).aspx or: to get the segment use browser inspector and check the ID of the segement in UI
 * @returns {Object} Resolved promise
 */
__.SP.ribbon.addIcon = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oList = __.SP.list.get( ctx, args.sList );
	var oIcon = oList.get_userCustomActions().add();
	oIcon.set_location( args.sRibbon );
	var sCommand = args.sLabel.toLowerCase();
	sCommand = sCommand.replace( /\s/g, "_" );
	var xml = '<CommandUIExtension xmlns="http://schemas.microsoft.com/sharepoint/">';
	xml += '<CommandUIDefinitions>';
	xml += '<CommandUIDefinition Location="' + args.sSegment + '.Controls._children">';
	xml += '<Button Id="Ribbon.' + args.sRibbon + '.' + args.sSegment + '.' + sCommand + '" ';
	xml += 'Command="' + sCommand + '" ';
	xml += 'Sequence="' + ( args.nSequence || 0 ) + '" ';
	xml += 'Image16by16="' + args.urlIcon16 + '" ';
	xml += 'Image32by32="' + args.urlIcon32 + '" ';
	xml += 'Description="' + args.sDescription + '" ';
	xml += 'LabelText="' + args.sLabel + '" ';
	xml += 'ToolTipTitle="' + ( args.sToolTipTitle || "" ) + '" ';
	xml += 'ToolTipDescription="' + ( args.sToolTipDescription || "" ) + '" ';
	xml += 'TemplateAlias="o1"/>';
	xml += '</CommandUIDefinition>';
	xml += '</CommandUIDefinitions>';
	xml += '<CommandUIHandlers>';
	xml += '<CommandUIHandler Command="' + sCommand + '" ';
	xml += 'CommandAction="' + args.sAction + '" ';
	if( args.sEnabled ) {
		xml += 'EnabledScript="' + args.sEnabled + '" ';
	}
	xml += '/>';
	xml += '</CommandUIHandlers>';
	xml += '</CommandUIExtension>';
	oIcon.set_commandUIExtension( xml );
	oIcon.update();
	ctx.load( oList, "UserCustomActions" );
	__.SP.exec( ctx, oList, function( oList ) {
		if( oList.sError ) {
			async.reject();
		}
		else {
			async.resolve();
		}
	} );
};



/**
 * Allows for an asynchronous task stack to deliver the enabled status of a ribbon icon.
 * @memberof __.SP.ribbon
 * @method syncEnabledScript
 * @async 
 * @instance
 * @example
 * var dnIcon = __find( "#Ribbon\\.ListItem\\.Manage\\.CancelItem-Large" )
 * var oAsync = ( new __.Async()
 *    .then( function( args ) {
 *        // do sg to resolve/reject
 *        async.resolve( { bEnabled : false } );
 *    )
 * return __.SP.ribbon.syncEnabledScript( dnIcon, oAsync );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.dnIcon DOM node of the ribbon icon (expected to use the A-tag holding the icon ID).
 * @param {String} args.oAsync An Async task stack (must not be started).
 * @param {String} args.sSegment name of the ribbon's segement 
 * @returns {Boolean} false
 */
__.SP.ribbon.syncEnabledScript = function( dnIcon, oAsync ) {
	var that = this;
	// first check if it is the first call on the icon
	// in which case we initialize our custom attributes
	if( ! dnIcon.hasAttribute( "osce-bEnabled" ) ) {
		// enabled state of icon
		dnIcon.setAttribute( "osce-bEnabled", false );
		// flag whether we reload ribbon with new state
		dnIcon.setAttribute( "osce-bBusy", false );
	}
	var bBusy = ( dnIcon.getAttribute( "osce-bBusy" ) == "true" );
	if( ! bBusy ) {
		// set loading gif after a little moment
		dnIcon.__hd = setTimeout( function() {
			dnIcon.__style( "position", "relative" );
			var sStyle = ( __.utils.misc.isIE() )
				? 'position:absolute;top:13px;margin-left:12px'
				: 'position:absolute;top:13px;margin-left:-7px' ;
			var hLoading = "<img class='osce-loader' style='" + sStyle + "' ";
			hLoading += " src='" + __.SP.icon.mp.x16.loading + "'/>";
			dnIcon.__append( hLoading );
		}, 501 );
		// reload ribbon with new state
		dnIcon.setAttribute( "osce-bBusy", true );
		dnIcon.setAttribute( "osce-bEnabled", false );
		oAsync.then( function( args ) {
			var async = __.Async.promise( args );
			dnIcon.setAttribute( "osce-bEnabled", args.bEnabled );
			setTimeout( function() {
				dnIcon.setAttribute( "osce-bBusy", false );
			}, 500 );
			// clear loading gif
			clearTimeout( dnIcon.__hd );
			var dnLoader = dnIcon.__find( ".osce-loader" );
			if( dnLoader ) {
				dnLoader.__remove();
			}
			__.SP.ribbon.reload();
		}, "set enabled state and refresh ribbon" )
		.start();
	}
	var bEnabled = ( dnIcon.getAttribute( "osce-bEnabled" ) == "true" );
	return bEnabled;
};


/**
 * Temporarily adds a ribbon icon into an existing ribbon group on-the-fly.
 * <br>It will try to find an icon image path by looking upt the image map (__.SP.icon.mp) using the lowercase label name (replacing spaces with underscores) and defaults to the placeholder icon (orange dot)
 * @memberof __.SP.ribbon
 * @method addTempIcon
 * @instance
 * @example
 * // add itom to clipboard group in edit ribbon in items edit form
 * dnAction = __.SP.ribbon.addTempIcon( {
 * 	  sLabel : "Approve Now" // image map key: "approve_now"
 * 	, dnGroup : __find( "#Ribbon\\.ListForm\\.Edit\\.Clipboard" )
 * 	, nPosition : 1
 * 	, fnAction : function() {
 * 		alert( 'approved' );
 * 	}
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sLabel Name of the icon
 * @param {Node} args.dnGroup DOM node of the group the icon should get appended. (Note: you get the node by ID of the LI element)
 * @param {function} args.fnAction Function to be executed on click
 * @param {Number} [args.nPosition] Position of the icon (0 is first position) by default icon is appended
 * @returns {Node} DOM node of the newly added icon
 */
__.SP.ribbon.addTempIcon = function( args ) {
	var hButton, sLabel;
	var kmpIcons = args.sLabel.toLowerCase().replace( /\s/g, "_" );
	var pathIconImg = __.SP.icon.mp.x32[ kmpIcons ];
	if( ! pathIconImg ) {
		pathIconImg = __.SP.icon.mp.x32.placeholder;
	}
	var hIcon = ' \
		<span class="ms-cui-section" id="" unselectable="on"> \
		<span class="ms-cui-row-onerow" id="" unselectable="on"> \
		<a class="ms-cui-ctl-large" mscui:controltype="Button" role="button" unselectable="on"> \
			<span class="ms-cui-ctl-largeIconContainer" unselectable="on"> \
			<span class="ms-cui-img-32by32 ms-cui-img-cont-float ms-cui-imageDisabled" unselectable="on"> \
			<img src="' + pathIconImg + '" unselectable="on" \> \
			</span> \
			</span> \
			<span class="ms-cui-ctl-largelabel" unselectable="on">' + args.sLabel + '</span> \
		</a> \
		</span> \
		</span> \
	';
	var dnIcons = args.dnGroup.__find( ".ms-cui-layout" );
	var dnIcon;
	if( typeof args.nPosition == "number" ) {
		var dnInsertBefore = dnIcons.__find( "span.ms-cui-section:nth-child(" + ( args.nPosition + 1 ) + ")" );
		console.log( dnInsertBefore );
		if( dnInsertBefore ) {
			dnIcon = dnInsertBefore.__before( hIcon );
		}
		else {
			console.warn( "desired icon position not available, will append" );
			dnIcon = dnIcons.__append( hIcon );
		}
	}
	else {
		dnIcon = dnIcons.__append( hIcon );
	}
	if( typeof args.fnAction == "function" ) {
		dnIcon.__find( "a" ).addEventListener( "click", function( e ) {
			e.stopPropagation();
			args.fnAction();
		} );
	}
	else {
		console.warn( "temp ribbon icon has no action function" );
	}
};

/**
 * Temporarily adds ribbon group to an existing ribbon on-the-fly.
 * <br>It adds an ID to the LI element starting with "Temp" plus the groups label joined by dots (e.g. Temp.Task.Actions)
 * @memberof __.SP.ribbon
 * @method addTempGroup
 * @instance
 * @example
 * // add group to edit ribbon in items edit form
 * dnGroup = __.SP.ribbon.addTempGroup( {
 * 	  dnRibbon : __find( "#Ribbon\\.ListForm\\.Edit" )
 * 	, nPosition : 0
 * 	, sLabel : "Task Actions"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sLabel Name of the group
 * @param {Node} args.dnRibbon DOM node of the ribbon the group should get appended. (Note: you get the node by ID of the UL element)
 * @param {Number} [args.nPosition] Position of the group (0 is first position) by default group is appended
 * @returns {Node} DOM node of the newly added group
 */
__.SP.ribbon.addTempGroup = function( args ) {
	var sid = "Temp." + args.sLabel.replace( " ", "." );
	var hGroup = ' \
		<li class="ms-cui-group" id="' + sid + '" unselectable="on"> \
			<span class="ms-cui-groupContainer" unselectable="on"> \
				<span class="ms-cui-groupBody" unselectable="on"> \
				<span class="ms-cui-layout" unselectable="on"> \
				</span> \
				</span> \
				<span class="ms-cui-groupTitle" unselectable="on">' + args.sLabel + '</span> \
			</span> \
			<span class="ms-cui-groupSeparator" unselectable="on"></span> \
		</li> \
	';
	if( typeof args.nPosition == "number" ) {
		var dnInsertBefore = args.dnRibbon.__find( "li:nth-child(" + ( args.nPosition + 1 ) + ")" );
		if( dnInsertBefore ) {
			return dnInsertBefore.__before( hGroup );
		}
		else {
			console.warn( "desired group position not available, will append" );
			return args.dnRibbon.__append( hGroup );
		}
	}
	else {
		return args.dnRibbon.__append( hGroup );
	}
}
/**
 * @namespace __.SP.workflow
 * @memberof __.SP
 */


__.SP.workflow = {};

__.SP.workflow.loadSPScripts = function( args ) {
	var async = __.Async.promise( args );
	if( SP && SP.WorkManagement ) {
		async.resolve();
	}
	else {
		var hdTimeout = setTimeout( function() {
			async.reject( "Could not load work management from SharePoint" );
		}, 10000 );
		RegisterSod('SP.WorkManagement.js', '/_layouts/15/SP.WorkManagement.js');
		// NB: need to take out SODing from current JS exectuion thread by 
		// timeout 0, for otherwise loadMultiple doesn't load
		setTimeout( function() {
			SP.SOD.loadMultiple( [ 'sp.js', 'SP.WorkManagement.js' ], function() {
				clearTimeout( hdTimeout );
				async.resolve();
			} )
		}, 100 );
	}
};

/**
 * Fetches all tasks personally assigned to the current user. NOTE: tasks assigned by group assignment will not show up in the list.
 * @memberof __.SP.workflow
 * @method myTasks
 * @async 
 * @instance
 * @example
 * __.SP.workflow.myTasks();
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * oTasks | (Object) | data object holding task split in completed and pending, as well as broken down by task list.
 * </pre>
 */


__.SP.workflow.myTasks = function( args ) {
	var async = __.Async.promise( args );
	async.then( __.SP.workflow, "loadSPScripts" )
	async.then( function( args ) {
		var ctx = __.SP.ctx();
		var ctx = __.SP.ctx();
		var oSession = new SP.WorkManagement.OM.UserOrderedSessionManager( ctx ).createSession();
		var oTaskQuery = new SP.WorkManagement.OM.TaskQuery( ctx );
		var oLocations = new SP.WorkManagement.OM.UserSettingsManager( ctx ).getAllLocations();
		var oMyTasks = oSession.readTasks( oTaskQuery );
		ctx.load( oLocations );
		ctx.load( oMyTasks );
		__.SP.exec( ctx, [ oLocations, oMyTasks ], function() {
			if( oLocations.sError ) {
				async.reject( oSet.sError );
			}
			if( oMyTasks.sError ) {
				async.reject( oSet.sError );
			}
			else {
				var lkvTasks = [];
				var oTasks = {
					 completed : {}
					,  pending : {}
				};
				var taskEnumerator = oMyTasks.getEnumerator();
				var locEnum = oLocations.getEnumerator();
				var mpLocations = {};
				while (locEnum.moveNext()) {
					var loc = locEnum.current;
					mpLocations[ loc.get_id() ] = loc.get_name();
				}
				while (taskEnumerator.moveNext()) {
					var task = taskEnumerator.current;
					var sInfo = mpLocations[ task.get_locationId() ];
					var sSite = "n/a";
					var sTaskList = "n/a";
					if( sInfo ) {
						var lsInfo = sInfo.split( ":" );
						if( lsInfo && lsInfo[ 1 ] ) {
							sSite = lsInfo[ 0 ].trim();
							sTaskList = lsInfo[ 1 ].trim();
						}
					}
					else if( task.get_isPersonal() ) {
						sSite = "MySite";
						sTaskList = "My Personal Tasks";
					}
					var dtDue = task.get_dueDate();
					var nDaysLeft = __.utils.dt.diff( dtDue );
					// check if no due date is set (in which case SP
					// puts year 1901 by default (sic!))
					if( nDaysLeft < -42800 ) {
						nDaysLeft = null;
						dtDue = null;
					}
					var kvAddInfo = null;
					var sAddInfo = task.get_serializedCustomDataForClient();
					if( sAddInfo ) {
						kvAddInfo = sAddInfo.__toJson();
					}
					var sStatus = ( task.get_isCompleted() )
						? "completed"
						: "pending" ;
					var kvTask = {
						  id : task.get_id()
						, sName : task.get_name()
						, customAttributes : task.get_customAttributes()
						, sDescription : task.get_description()
						, dtStart : task.get_startDate()
						, dtDue : dtDue
						, nDaysLeft : nDaysLeft
						, urlEdit : task.get_editUrl()
						, isReadOnly : task.get_isReadOnly()
						, dtModified : task.get_lastModified()
						, idLocation : task.get_locationId()
						, sSite : sSite
						, pinAge : task.get_pinAge()
						, kvAddInfo : kvAddInfo
					};
					if( ! oTasks[ sStatus ][ sTaskList ] ) {
						oTasks[ sStatus ][ sTaskList ] = [];
					}
					oTasks[ sStatus ][ sTaskList ].push( kvTask );
				}
				async.resolve( { oTasks : oTasks } );
			}
		} );
	} );
	async.resolve();
}
/**
 * @namespace __.SP.group
 * @memberof __.SP
 */

__.SP.group = {};

/**
 * Creates a new SharePoint group
 * @memberof __.SP.group
 * @method add
 * @async 
 * @instance
 * @example
 * __.SP.group.add( {
 *       sName : "TaskAdmins"
 *     , sDescription : "users that can administer Tasks" 	
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sName name of the group
 * @param {String} [args.sDescription] description of the group
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * oGroup | (Object) | SP object of created group
 * </pre>
 */
__.SP.group.add = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oWeb = ctx.get_web();
	var oCreate = new SP.GroupCreationInformation();
	oCreate.set_title( args.sName );
	if( args.sDescription ) {
		oCreate.set_description( args.sDescription );
	}
	oGroup = oWeb.get_siteGroups().add( oCreate );
	ctx.load( oGroup );
	__.SP.exec( ctx, oGroup, function( oGroup ) {
		if( oGroup.sError ) {
			async.reject( oGroup );
		}
		else {
			async.resolve();
		}
	} );
}

/**
 * Adds a user to a SharePoint group
 * @memberof __.SP.group
 * @method addUser
 * @async 
 * @instance
 * @example
 * __.SP.group.add( {
 *       sName : "OSCE-test\\jriemer"
 *     , sGroup : "TaskAdmins"
 * } );
 * @param {Object} args a parameter object holding the following values
 * @param {String} args.sUser domain/login of user
 * @param {String} args.sGroup name of the group
 * @returns {Object} Resolved promise holding the following values 
 * <pre class='return-object'>
 * oUser | (Object) | SP object of added user
 * </pre>
 */
__.SP.group.addUser = function( args ) {
	var async = __.Async.promise( args );
	var ctx = __.SP.ctx();
	var oUser = ctx.get_web().ensureUser( args.sUser );
	var oGroup = ctx.get_web().get_siteGroups().getByName( args.sGroup );
	oGroup.get_users().addUser( oUser );
	ctx.load( oUser );
	ctx.load( oGroup );
	__.SP.exec( ctx, oUser, function( oUser ) {
		if( oUser.sError ) {
			async.reject( oUser );
		}
		else {
			async.resolve();
		}
	} );
}
