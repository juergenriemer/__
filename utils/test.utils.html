<html>
<script src="__.Utils.js"></script>
<body>
<h3>Unit tests for __.Async.js</h3>
<div id="output"></div>
<script>
cOkAssert = 0;
cErrAssert = 0;
assert = function( b, s ) {
	var dn = document.getElementById( "output" );
	if( b === true ) {
		s = 'OK: ' + s;
		cOkAssert++;
	} else {
		s = 'ERR: ' + s + " (check console)";
		console.warn( 'ERR: ' + s );
		console.warn( o1 );
		console.warn( o2 );
		cErrAssert++;
	}
	dn.innerHTML += s + "<br>";
}

// REF: should be o.
var lo = [ { v : 5 }, { v : 11 }, { v : 1 } ];
var loSorted = __.l.kSort( lo, "v" );
var eloSorted = [ { v : 1 }, { v : 5 }, { v : 11 } ];
assert( ( __.o.s( loSorted ) == __.o.s( eloSorted ) ), "__.l.kSort" );

var lo = [ {v:5 }, {v:11}, {v:-1}, {v:null},{x:'1'} ];
var loSorted = __.l.kSort( lo, "v" );
var eloSorted = [ {x:'1'},{v:null},{v:-1},{v:1}, {v:5}, {v:11} ];
assert( ( __.o.s( loSorted ) == __.o.s( eloSorted ) ), "__.l.kSort (null,-1)" );

// __.s.tokenize
var s = __.s.tokenize( "Hi 'Mom',\nHi Dad" ); // himom,hidad
var es = "himom,hidad";
assert( s, es, "__.s.tokenize" );

// __.s.unCamelCase
var s = __.s.unCamelCase( "HiMom" );
var es = "Hi Mom";
assert( s, es, "__.s.unCamelCase" );

// __.l.kSort
var lo = [ { v : 12 }, { x : 11 }, { s : "x" },  { v : 2 } ];
lo = __.l.kSort( lo, "v" );
elo = [ {x:11}, {s:"x"}, { v : 2} , { v : 12 } ];
assert( lo, elo, "__.l.kSort" );

// __.dt.date
var o = __.dt.date( "2018/04/04" );
var eo = {nDay:4,nMonth:3,olla:{ a:1,b:{u:"x"}},sDay:"Wednesday",sDayShort:"Wed",sMonth:"April",sMonthShort:"Apr"};
recurs = function( o ) {
	path = ""
	for( var k in o ) {
		if( typeof o[ k ] == "object" && o[ k ] !== null ) {
			path = ""
			recurs( o[ k ] );
		}
		else {
			path += k;
			console.log( path + " "+ k + " " + o[ k ] );
		}
	}
}
recurs( eo );
assert( o, eo, "__.dt.date" );


console.log( "> __.o.equal, __.o.diff" );

var o1 = {a:[1,3,1,[false,true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",99,-1]]]};
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 4" )

var o1 = [{a:1},[99,-1,"g"]];
var o2 = [{a:1},[99,-1,"g"]];
assert( __.o.equal( o1,o2 ), "object with multiple undefined" )

var o1 = {a:[,[[]],[]]}; 
var o2 = {a:[,[],[[]]]};
assert( false === __.o.equal( o1,o2 ), "object with multiple undefined" )

var o1 = {a:[]}; var o2 = {a:[0]};
assert( false === __.o.equal( o1,o2 ), "object with undefined, zero" )

var o1 = {a:[0,[[0]]]}; var o2 = {a:[0,[0,[]]]};
assert( false === __.o.equal( o1,o2 ), "nested object with undefined, zero" )

var o1 = {a:[[[,0]],]}; var o2 = {a:[,[[0,]]]};
assert( false === __.o.equal( o1,o2 ), "nested object with undefined, zero 2" )

assert( false === __.o.equal( [],[0] ), "undefined, zero" )

var o1 = {a:[1,,4]};
var o2 = {a:[1,,4]};
assert( __.o.equal( o1, o2 ), "object equal" );

assert( false === __.o.equal( [0],[] ), "zero, undefined" )
assert( __.o.equal( [],[] ), "undefined, undefined" )

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:2,c:1};
var ldiff = {o1:[["diff", "b", 1, 2]],o2:[["diff", "b", 2, 1]]};
assert( false === __.o.equal( o1, o2 ), "simple object, many keys, diff val" );
assert( __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = {a:[1]};
var o2 = {a:[1]};
assert( __.o.equal( o1, o2 ), "object equal" );

var o1 = {a:1};
var o2 = {a:1};
assert( __.o.equal( o1, o2 ), "simple object equal" );
var o1 = {a:1};
var o2 = {a:true};
assert( false === __.o.equal( o1, o2 ), "simple object diff type" );
var ldiff = {o1:[["length",null,7,10],["type", "a", 1, true]],o2:[["length",null,7,10],["type", "a", true, 1]]};
assert( __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:1,c:1};
assert( __.o.equal( o1, o2 ), "simple object, many keys" );

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:2,c:1};
assert( false === __.o.equal( o1, o2 ), "simple object, many keys, diff val" );
var ldiff = {o1:[["diff", "b", 1, 2]],o2:[["diff", "b", 2, 1]]};
assert( __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = [1];
var o2 = [1];
assert( __.o.equal( o1, o2 ), "simple array" );

var o1 = [1,2,3];
var o2 = [1,2,3];
assert( __.o.equal( o1, o2 ), "simple array, multiple elements" );

var o1 = [1,2,3];
var o2 = [3,1,2];
assert( __.o.equal( o1, o2 ), "!!simple array, multiple elements unordered" );

var o1 = { a: [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ] };
var o2 = { a: [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ] };
assert( __.o.equal( o1, o2 ), "complex object" );

var o1 = [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ];
var o2 = [ { a:1,b:[1] }, { c:[{u:7,l:[[[4]]]}]} ];
assert( false === __.o.equal( o1, o2 ), "complex object, wrong value" );
var ldiff = {o1:[["diff", "1.c.0.l.0.0.0", 5, 4]],o2:[["diff", "1.c.0.l.0.0.0", 4, 5]]};
assert( __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = [ [ {a:1},{a:2},{a:3} ], [ {a:1},{a:2},{a:3} ] ];
var o2 = [ [ {a:1},{a:2},{a:3} ], [ {a:1},{a:2},{a:3} ] ];
assert( __.o.equal( o1, o2 ), "multiple objects duplicated in arrays" );

var o1 = [ [ {a:1},{b:2},{a:3} ], [ {a:1},{b:2},{a:3} ] ];
var o2 = [ [ {a:1},{b:2},{a:3} ], [ {a:1},{b:2},{a:3} ] ];
assert( __.o.equal( o1, o2 ), "multiple objects in arrays" );

var o1 = { fn:function(){var x=1} };
var o2 = { fn:function(){var x=1} };
assert( __.o.equal( o1, o2 ), "functions" );

var o1 = { fn:function(){var x=1} };
var o2 = { fn:function(){var x=1} };
assert( __.o.equal( o1, o2 ), "functions with spaces" );

var o1 = { b:new Date(2018,1,1) };
var o2 = { b:new Date(2018,1,1) };
assert( __.o.equal( o1, o2 ), "same dates" );

var o1 = { b:new Date(2018,1,1) };
var o2 = { b:new Date(2018,1,2) };
assert( false === __.o.equal( o1, o2 ), "different dates" );

assert( false === __.o.equal( {l:[4,3],s:{a:1}}, {l:[3,4],s:[11112]} ), "object with different types" );
assert( __.o.equal( {l:[4,3],s:{a:1}}, {l:[3,4],s:{a:1}} ), "unordered objects" );
assert( false === __.o.equal( [null],[0] ), "null, zero" )
assert( false === __.o.equal( [],[0] ), "undefined, zero" )
assert( false === __.o.equal( [0],[""] ), "zero, empty string" )
assert( false === __.o.equal( [],[""] ), "undefined, empty string" )
assert( false === __.o.equal( [null],[""] ), "null, empty string" )
assert( false === __.o.equal( [null],[0] ), "null, zero" )
assert( false === __.o.equal( [null],[] ), "null, undefined" )
assert( __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
), "obect various types" );
assert( false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:false,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
), "object various types, diff values" );
assert( false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,2),c:-1,d:[[[1]]] }
), "object various types, diff values 2" );
assert( false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:0,d:[[[1]]] }
), "object various types, diff values 3" );
assert( false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:0,d:[[[2]]] }
), "object various types, diff values 4" );
assert( __.o.equal(
	  { a:1,b:{c:{d:{e:1}}}}
	, { a:1,b:{c:{d:{e:1}}}}
), "nested objects" );
o1  = {
	_ : [ { x:1, y:2 }, { x:1, y:2 }, { x:1, y:2 } ]
	, a : { a1:true, a2:new Date( 2018,1,1 ), a3:6 }
	, b : {
		b1 : [ 6, 1, 7, 2, 3 ]
		, b2 : {
			  bb1 : 1
			, bb2 : 2
		}
	}
	, c : "by"
	, f : function() { return 'olla' }
}
o2  = {
	_ : [ { x:1, y:2 }, { x:1, y:2 }, { x:1, y:2 } ]
	, a : { a1:true, a2:new Date( 2018,1,1 ), a3:6 }
	, b : {
		b1 : [ 6, 1, 7, 2, 3 ]
		, b2 : {
			  bb1 : 1
			, bb2 : 2
			, bb3 : 3
		}
	}
	, c : "hi"
	, f : function() { return 'olla' }
}

assert( false === __.o.equal( o1, o2 ), "complex object, diff struc" );
delete o2.b.b2.bb3;
assert( false === __.o.equal( o1, o2 ) , "complex object, diff struc 2" );
o2.c = "by";
assert( __.o.equal( o1, o2 ), "complex object, corrected" );
assert( "olla" == o1.f(), "test function of complex object" );
assert( "olla" == o2.f(), "test function of complex object 2" );
var o1 = {a:["a",-1,true]}
var o2 = {a:["a",-1,true]}
assert( __.o.equal( o1, o2 ), "mixed arrays" )

var o1 = {a:[1,true,"a"]}
var o2 = {a:["a",1,true]}
var o1 = ["a",1,2,3,"b"]
var o2 = ["a","b",3,1,2]
assert( __.o.equal( o1, o2 ), "mixed arrays unordered" )

var o1 = [[[["a",1,2,3,"b"]]]];
var o2 = [[[["a","b",3,1,2]]]];
assert( __.o.equal( o1, o2 ), "nested mixed arrays unordered" )

var o1 = {a:[7,2,3,[5,1,2,[8,1,3]]]};
var o2 = {a:[7,2,3,[5,1,2,[8,1,3]]]};
assert( __.o.equal( o1, o2 ), "nested arrays" )

var o1 = [7,2,3,[5,1,2,[8,1,3]]];
var o2 = [7,2,3,[5,1,2,[8,1,3]]];
assert( __.o.equal( o1, o2 ), "nested arrays 1" )

var o1 = [7,2,[5,4,[8,1]]];
var o2 = [7,2,[5,4,[8,1]]];
assert( __.o.equal( o1, o2 ), "nested arrays 2" )

var o1 = {a:[{b:1},[1,2],4,5]}
var o2 = {a:[{b:1},[1,2],4,5]}
assert( __.o.equal( o1, o2 ), "nested arrays complex" )

var o1 = {a:[1,3,1,[false,true,{a:1},["g",-1,99,[1]]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",-1,99,[1]]]]};
assert( __.o.equal( o1, o2 ), "nested ordered arrays complex 2" )

var o1 = {a:[["g",-1,99,[1,3]],3,1,1,{a:1}]};
var o2 = {a:[1,3,1,{a:1},[99,-1,"g",[3,1]]]};
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 3" )

var o1 = {a:[1,3,1,[false,true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",99,-1]]]};
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 4" )

var o1 = {a:[1,[true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,[true,{a:1},["g",99,-1]]]};
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 5" )

var o1 = {a:[{a:1},[99,-1,"g"]]};
var o2 = {a:[{a:1},["g",99,-1]]};
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 6" )

var o1 = [{a:1},[99,-1,"g"]];
var o2 = [{a:1},["g",99,-1]];
assert( __.o.equal( o1, o2 ), "nested unordered arrays complex 7" )
console.log( "=======", "[OK: " + cOkAssert + "] [ERR: " + cErrAssert + "]", "========" );
console.log( ">>>>>>>>>>>> __.utils.js" );

</script>
<!--
var sjs = __.dn_( "#__" ).value;
var lsls = sjs.split( "\n" );
var bComment = false;
var bExample = false;
var bResult = false;
var oTest = {};
lsls.forEach( function( s ) {
	if( /\s.*\/\*/.test( s ) ) {
		bComment = true;
		bExample = false;
		bResult = false;
		oTest = {
			  lsExample : []
			, lsResult : []
		};
	}	
	else if( /\s.*\*\//.test( s ) ) {
		bComment = false;
	}	
	else if( /\* @param/.test( s ) ) {
		bComment = false;
	}	
	else if( /\* @returns/.test( s ) ) {
		bComment = false;
	}	
	else if( bComment ) {
		var ls_o = s.match( /\* @memberof (.*)/ );
		if( ls_o && ls_o[ 1 ] ) {
			var so = ls_o[ 1 ];
			eval( "oTest.o = " + so );
		}
		var ls_sfn = s.match( /\* @method (.*)/ );
		if( ls_sfn && ls_sfn[ 1 ] ) {
			var sfn = ls_sfn[ 1 ];
			eval( "oTest.fn = oTest.o[ '" + sfn + "']" );
		}
		if( bExample ) {
			if( ! /\* @.*\b/.test( s ) ) {
				oTest.lsExample.push( s.replace( /\*/, "" ) );
			}
		}
		if( bResult ) {
			if( ! /\* @.*\b/.test( s ) ) {
				oTest.lsResult.push( s.replace( /\*/, "" ) );
			}
		}
		if( /\* @example/.test( s ) ) {
			s = s.replace( /\* @.*\b/, "" );
			oTest.lsExample.push( s.replace( /\*/, "" ) );
			bExample = true;
			bResult = false;
		}	
		if( /\* @result/.test( s ) ) {
			s = s.replace( /\* @.*\b/, "" );
			oTest.lsResult.push( s.replace( /\*/, "" ) );
			bExample = false;
			bResult = true;
		}	
	}
	if( !bComment && bResult ) {
		oTest.sjsExample = oTest.lsExample.join( " " ).replace( /\s\s/g, "" );
console.log( oTest.sjsExample )
		console.log( "------------" );
		console.log( oTest );
		eval( oTest.sjsExample );


		oTest.lsResult.forEach( function( s ) {
			s = s.replace( /\s\s/g, "" ).trim();
			if( s ) {
				var ss = "b=(" + s + ")"; 
				console.log( ss );
				eval( ss );
				if( b ) {
					console.log( "OK" );
				}
				else {
					console.log( "ERROR" );
				}
			}

		} );
		console.log( "------------" );
		bResult = false;
	}
} );
</script>
-->
</body>
</html>
