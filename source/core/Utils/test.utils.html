<html>
<script src="__.utils.js"></script>
<body>
<h3>Unit tests for __.Utils.js</h3>
<div id="output"></div>
<script>
cOkAssert = 0;
cErrAssert = 0;
assert = function( x1, x2, s ) {
	var dn = document.getElementById( "output" );
	var b = true;
	if( typeof x1 == "object" && typeof s == "string" ) {
		if( __.o.diff( x1, x2 ) ) {
			console.warn( 'ERR: ' + s );
			console.warn( "expected:", x2 );
			console.warn( "result:", x1 );
		}
		else {
			s = "[OK] " + s;
		}
	}
	else if( typeof x1 == "object" && typeof x2 == "string" ) {
		console.log( '>> single true' );
	}
	else {
		if( x1 !== x2 ) {
			console.warn( 'ERR: ' + s );
			console.warn( "expected:", x2 );
			console.warn( "result:", x1 );
		}
		else {
			s = "[OK] " + s;
		}
	}
	dn.innerHTML += s + "<br>";
}
/* ** __.s ** */

// __.s.o

s = '{"sName":"John","nAge":44}';
o = __.s.o ( s );
eo =  { sName:'John', nAge:44}
assert( o, eo, "__.s.o" );

s = "{'sName':'John','nAge':44}";
o = __.s.o ( s );
eo = null;
assert( o, eo, "__.s.o (single quotes)" );

s = "{sName:'John','nAge':44}";
o = __.s.o ( s );
eo = null;
assert( o, eo, "__.s.o (missing quotes)" );

s = "sName:'John','nAge':44";
o = __.s.o ( s );
eo = null;
assert( o, eo, "__.s.o (broken json)" );

// __.s.empty
s = "";
b = __.s.empty( s );
eb = true;
assert( b, eb, "__.s.empty" );

s = "  ";
b = __.s.empty( s );
eb = true;
assert( b, eb, "__.s.empty (spaces)" );

s = " 0 ";
b = __.s.empty( s );
eb = false;
assert( b, eb, "__.s.empty (string)" );

s = 12;
b = __.s.empty( s );
eb = false;
assert( b, eb, "__.s.empty (number)" );

// __.s.camelCase
var s = __.s.camelCase( "   hi mom   how are you" );
var es = "Hi Mom How Are You";
assert( s, es, "__.s.camelCase" );

// __.s.unCamelCase
var s = __.s.unCamelCase( "   HiMomHowAreYou   " );
var es = "Hi Mom How Are You";
assert( s, es, "__.s.unCamelCase" );

var s = __.s.unCamelCase( "HiMomIAmHome" );
var es = "Hi Mom I Am Home";
assert( s, es, "__.s.unCamelCase (single capital)" );

var s = __.s.unCamelCase( "OSCE" );
var es = "OSCE";
assert( s, es, "__.s.unCamelCase (akronym)" );

var s = __.s.unCamelCase( "OCEEAEvents" );
var es = "OCEEA Events";
assert( s, es, "__.s.unCamelCase (akronym with word)" );

// __.s.tokenize
s = __.s.tokenize( "Hi 'Mom',\nHi Dad" ); // himom,hidad
es = "himom,hidad";
assert( s, es, "__.s.tokenize" );

s = __.s.tokenize( "   Hi 'Mom',\nHi   Dad   \n\n\n" ); // himom,hidad
es = "himom,hidad";
assert( s, es, "__.s.tokenize (multiple spaces, new lines)" );

/* ** __.n ** */

// __.n.within

n = __.n.within( 1, [ 5, 9 ] );
en = 5;
assert( n, en, "__.n.within" );

n = __.n.within( 4, [ 5, 9 ] );
en = 5;
assert( n, en, "__.n.within (left boundary outside)" );

n = __.n.within( 5, [ 5, 9 ] );
en = 5;
assert( n, en, "__.n.within (left boundary inside)" );

n = __.n.within( 6, [ 5, 9 ] );
en = 6;
assert( n, en, "__.n.within (left boundary inside 2)" );

n = __.n.within( 10, [ 5, 9 ] );
en = 9;
assert( n, en, "__.n.within (right boundary outside)" );

n = __.n.within( 9, [ 5, 9 ] );
en = 9;
assert( n, en, "__.n.within (right boundary inside)" );

n = __.n.within( 8, [ 5, 9 ] );
en = 8;
assert( n, en, "__.n.within (right boundary inside 2)" );

n = __.n.within( -8, [ 5, 9 ] );
en = 5;
assert( n, en, "__.n.within (negative value)" );

n = __.n.within( -8, [ -5, 9 ] );
en = -5;
assert( n, en, "__.n.within (negative boundary)" );

n = __.n.within( -5, [ -5, 9 ] );
en = -5;
assert( n, en, "__.n.within (negative boundary)" );


/* ** __.l ** */

// __.l.del

l = [ 1, 3, 7 ];
el = [ 1, 3 ];
__.l.del( l, 7 );
assert( l, el, "__.l.del (single elem)" );

l = [ 1, 3, 7, 7, 8 ];
el = [ 1, 3, 8 ];
__.l.del( l, 7 );
assert( l, el, "__.l.del (multiple elems)" );

l = [ 7, 1, 3, 7, 7 ];
el = [ 1, 3 ];
__.l.del( l, 7 );
assert( l, el, "__.l.del (multiple elems boundary)" );

l = [ 7, 7 ];
el = [ ];
__.l.del( l, 7 );
assert( l, el, "__.l.del (all removed)" );

l = [ 1, 3 ];
el = [ 1, 3 ];
__.l.del( l, 7 );
assert( l, el, "__.l.del (none removed)" );

// __.l.contains
l = [ 1, 3, 7 ];
b = __.l.contains( l, 7 );
eb = true;
assert( b, eb, "__.l.contains (true)" );

l = [ 1, 3 ];
b = __.l.contains( l, 7 );
eb = false;
assert( b, eb, "__.l.contains (false)" );

l = [];
b = __.l.contains( l, 7 );
eb = false;
assert( b, eb, "__.l.contains (empty array)" );

// __.l.equal

l1 = [ 1, 2, 3 ];
l2 = [ 1, 2, 3 ];
b = __.l.equal( l1, l2 );
eb = true;
assert( b, eb, "__.l.equal (simple)" );

l1 = [ 2, 1, 3 ];
l2 = [ 1, 2, 3 ];
b = __.l.equal( l1, l2 );
eb = false;
assert( b, eb, "__.l.equal (different order)" );

l1 = [ 2, 1, 3 ];
l2 = [];
b = __.l.equal( l1, l2 );
eb = false;
assert( b, eb, "__.l.equal (one empty)" );

// __.l.empty

l = [ ];
b = __.l.empty( l );
eb = true;
assert( b, eb, "__.l.empty (true)" );

l = [null];
b = __.l.empty( l );
eb = false;
assert( b, eb, "__.l.empty (null)" );

l = [""];
b = __.l.empty( l );
eb = false;
assert( b, eb, "__.l.empty (empty string)" );

l = [0];
b = __.l.empty( l );
eb = false;
assert( b, eb, "__.l.empty (zero)" );

l = [[]];
b = __.l.empty( l );
eb = false;
assert( b, eb, "__.l.empty (array)" );

// __.l.kSort (put in o?)

lo = [ {v:5}, {v:11}, {v:1} ];
lo = __.l.kSort( lo, "v" );
elo = [ {v:1}, {v:5}, {v:11} ];
assert( lo, elo, "__.l.kSort (numbers)" );

lo = [ {v:"Z"}, {v:"b"}, {v:"A"}, {v:"a"}, {v:"z"} ];
lo = __.l.kSort( lo, "v" );
elo = [{v:"A"}, {v:"Z"}, {v:"a",}, {v:"b"}, {v:"z"} ];
assert( lo, elo, "__.l.kSort (strings)" );

lo = [ {v:5}, {v:1}, {v:"a"}, {v:"z"} ];
lo = __.l.kSort( lo, "v" );
elo = [ {v:1}, {v:5}, {v:"a"}, {v:"z"} ];
assert( lo, elo, "__.l.kSort (mixed)" );

lo = [ {v:12}, { v:11}, {s:"x"}, {v:2} ];
lo = __.l.kSort( lo, "v" );
elo = [ {v:2}, {v:11}, {v:12}, {s:"x"} ];
assert( lo, elo, "__.l.kSort (add. keys)" );

lo = [ {v:5 }, {v:11}, {v:1}, {v:-1}, {v:null},{x:'1'} ];
lo = __.l.kSort( lo, "v" );
elo = [ {v:-1}, {v:null}, {v:1}, {v:5}, {v:11},{x:'1'} ];
assert( lo, elo, "__.l.kSort (null, -1)" );

lo = [ {v:"g"}, {x:11}, {s:"x"}, {v:"a"} ];
lo = __.l.kSort( lo, "v" );
elo = [ {v:"a"}, {v:"g"}, {s:"x"}, {x:11}];
assert( lo, elo, "__.l.kSort (string values)" );

/* ** __.o ** */

// __.o.s
o =  { sName:'John', nAge:44}
s = __.o.s( o );
es = '{"sName":"John","nAge":44}';
assert( s, es, "__.o.s (simple)" );

o = {}
s = __.o.s( o );
es = '{}';
assert( s, es, "__.o.s (empty)" );

o = 12
s = __.o.s( o );
es = "12";
assert( s, es, "__.o.s (no object)" );

o = {};
o.ref = o;
s = __.o.s( o );
es = null;
assert( s, es, "__.o.s (circular reference)" );

// __.o.k

o = { "country" : "Belgium" }
k = __.o.k( o );
ek = "country";
assert( k, ek, "__.o.k (single attribute)" );

o = { "country" : "Belgium", "address" : "street 11" }
k = __.o.k( o );
ek = "country";
assert( k, ek, "__.o.k (mulitple attributes)" );

o = {};
k = __.o.k( o );
ek = null
assert( k, ek, "__.o.k (empty object)" );

o = [ { "country" : "Belgium" } ];
k = __.o.k( o );
ek = "0" 
assert( k, ek, "__.o.k (array)" );

o = "country";
k = __.o.k( o );
ek = "0";
assert( k, ek, "__.o.k (no object)" );

// __.o.kk

o = { sName : "John" };
lk = __.o.kk( o );
elk = [ "sName" ];
assert( lk, elk, "__.o.kk (one attribute)" );

o = { sName : "John", nAge : 44, mpCards : { "a" : 1, "b" : 2 } };
lk = __.o.kk( o );
elk = [ "sName", "nAge", "mpCards" ];
assert( lk, elk, "__.o.kk (multiple attribues)" );

o = {};
lk = __.o.kk( o );
elk = [];
assert( lk, elk, "__.o.kk (empty object)" );

// __.o.add


o1 = { a:1, b:2 };
o2 = { c:3, d:4 };
__.o.add( o1, o2 );
eo1 = { a:1, b:2, c:3, d:4 };
eo2 = { c:3, d:4 };
assert( o1, eo1, "__.o.add (two, one-level, different objects)" );
assert( o2, eo2, "__.o.add (second object unchanged)" );

o1 = { a:1, b:2 };
o2 = { a:3, d:4 };
__.o.add( o1, o2 );
eo1 = { a:3, b:2, d:4 };
assert( o1, eo1, "__.o.add (two, one-level, intersections)" );

o1 = { a:1, b:2 };
o2 = { a:{f:[1,2,{i:{o1:2,o2:3}}]}, d:4 };
__.o.add( o1, o2 );
eo1 = { a:{f:[1,2,{i:{o1:2,o2:3}}]}, b:2, d:4 };
assert( o1, eo1, "__.o.add (multi-level, intersections)" );

o1 = {};
o2 = { a:1, b:2 };
__.o.add( o1, o2 );
eo1 = { a:1, b:2 };
assert( o1, eo1, "__.o.add (first object empty)" );
o1 = { a:1, b:2 };

o1 = { a:1, b:2 };
o2 = {};
__.o.add( o1, o2 );
eo1 = { a:1, b:2 };
assert( o1, eo1, "__.o.add (second object empty)" );

o1 = {};
o2 = {};
__.o.add( o1, o2 );
eo1 = {};
assert( o1, eo1, "__.o.add (both objects empty)" );

o1 = { a:1, b:2 };
o2 = "hi";
__.o.add( o1, o2 );
eo1 = { 0:"h", 1:"i", a:1, b:2 };
assert( o1, eo1, "__.o.add (second param string)" );

o1 = "hi";
o2 = { a:1, b:2 };
__.o.add( o1, o2 );
eo1 = "hi";
assert( o1, eo1, "__.o.add (first param string)" );

o1 = [1,2];
o2 = { a:1, b:2 };
__.o.add( o1, o2 );
eo1 = [ 1, 2 ];
eo1["a"] = 1;
eo1["b"] = 2;
assert( o1, eo1, "__.o.add (first param array)" );

o1 = { a:1, b:2 };
o2 = [1,2];
__.o.add( o1, o2 );
eo1 = { 0:1, 1:2, a:1, b:2 };
assert( o1, eo1, "__.o.add (second param array)" );

o1 = [1,2];
o2 = [3,4];
__.o.add( o1, o2 );
eo1 = [3,4];
assert( o1, eo1, "__.o.add (both params array)" );

// __.o.kRename


o = { sName : "John", nAge : 44 };
__.o.kRename( o, "sName", "sFirstName" );
eo = { sFirstName : "John", nAge : 44 };
assert( o, eo, "__.o.kRename (simple)" );

o = {"a":1,"b":2};
__.o.kRename( o, "a", "b" );
eo = {"b":1};
assert( o, eo, "__.o.kRename (key already exists)" );

lo = [ {"a":1},{"a":3},{"a":"hi"} ];
__.o.kRename( lo, "a", "b" );
elo = [ {"a":1},{"a":3},{"a":"hi"} ];
assert( lo, elo, "__.o.kRename (array)" );

lo = [ {"a":1},{"a":3},{"a":"hi"} ];
lo.forEach( function( o ) {
	__.o.kRename( o, "a", "b" );
} );
elo = [ {"b":1},{"b":3},{"b":"hi"} ];
assert( lo, elo, "__.o.kRename (iterate list of objects)" );

// __.o.c


o = { sName : "John", nAge : 44 };
c = __.o.c( o );
ec = 2;
assert( c, ec, "__.o.c (simple)" );

o = { a:{d:{e:1}}, b:2, c:{f:1} };
c = __.o.c( o );
ec = 3;
assert( c, ec, "__.o.c (nested object)" );

o = { a:1, b:2, c:[1,2] };
c = __.o.c( o );
ec = 3;
assert( c, ec, "__.o.c (with arrays)" );

o = { a:1, b:2, b:4 };
c = __.o.c( o );
ec = 2;
assert( c, ec, "__.o.c (duplicate key)" );

o = { a:1, b:2, c:null };
c = __.o.c( o );
ec = 3;
assert( c, ec, "__.o.c (key nulled)" );

o = [ 1,2,3,4];
c = __.o.c( o );
ec = 4;
assert( c, ec, "__.o.c (object is array)" );

o = "hi mom";
c = __.o.c( o );
ec = 6;
assert( c, ec, "__.o.c (object is string)" );

// __.dt.date
var o = __.dt.date( "2018/04/04" );
var eo = {nDay:4,nMonth:3,olla:{ a:1,b:{u:"x"}},sDay:"Wednesday",sDayShort:"Wed",sMonth:"April",sMonthShort:"Apr"};
recurs = function( o ) {
	path = ""
	for( var k in o ) {
		if( typeof o[ k ] == "object" && o[ k ] !== null ) {
			path = ""
			recurs( o[ k ] );
		}
		else {
			path += k;
			console.log( path + " "+ k + " " + o[ k ] );
		}
	}
}
recurs( eo );
assert( o, eo, "[OK] __.dt.date" );


console.log( "> __.o.equal, __.o.diff" );

var o1 = {a:[1,3,1,[false,true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",99,-1]]]};
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 4" )

var o1 = [{a:1},[99,-1,"g"]];
var o2 = [{a:1},[99,-1,"g"]];
assert( true,  __.o.equal( o1,o2 ), "object with multiple undefined" )

var o1 = {a:[,[[]],[]]}; 
var o2 = {a:[,[],[[]]]};
assert( true,  false === __.o.equal( o1,o2 ), "object with multiple undefined" )

var o1 = {a:[]}; var o2 = {a:[0]};
assert( true,  false === __.o.equal( o1,o2 ), "object with undefined, zero" )

var o1 = {a:[0,[[0]]]}; var o2 = {a:[0,[0,[]]]};
assert( true,  false === __.o.equal( o1,o2 ), "nested object with undefined, zero" )

var o1 = {a:[[[,0]],]}; var o2 = {a:[,[[0,]]]};
assert( true,  false === __.o.equal( o1,o2 ), "nested object with undefined, zero 2" )

assert( true,  false === __.o.equal( [],[0] ), "undefined, zero" )

var o1 = {a:[1,,4]};
var o2 = {a:[1,,4]};
assert( true,  __.o.equal( o1, o2 ), "object equal" );

assert( true,  false === __.o.equal( [0],[] ), "zero, undefined" )
assert( true,  __.o.equal( [],[] ), "undefined, undefined" )

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:2,c:1};
var ldiff = {o1:[["diff", "b", 1, 2]],o2:[["diff", "b", 2, 1]]};
assert( true,  false === __.o.equal( o1, o2 ), "simple object, many keys, diff val" );
assert( true,  __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = {a:[1]};
var o2 = {a:[1]};
assert( true,  __.o.equal( o1, o2 ), "object equal" );

var o1 = {a:1};
var o2 = {a:1};
assert( true,  __.o.equal( o1, o2 ), "simple object equal" );
var o1 = {a:1};
var o2 = {a:true};
assert( true,  false === __.o.equal( o1, o2 ), "simple object diff type" );
var ldiff = {o1:[["length",null,7,10],["type", "a", 1, true]],o2:[["length",null,7,10],["type", "a", true, 1]]};
assert( true,  __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:1,c:1};
assert( true,  __.o.equal( o1, o2 ), "simple object, many keys" );

var o1 = {a:1,b:1,c:1};
var o2 = {a:1,b:2,c:1};
assert( true,  false === __.o.equal( o1, o2 ), "simple object, many keys, diff val" );
var ldiff = {o1:[["diff", "b", 1, 2]],o2:[["diff", "b", 2, 1]]};
assert( true,  __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = [1];
var o2 = [1];
assert( true,  __.o.equal( o1, o2 ), "simple array" );

var o1 = [1,2,3];
var o2 = [1,2,3];
assert( true,  __.o.equal( o1, o2 ), "simple array, multiple elements" );

var o1 = [1,2,3];
var o2 = [3,1,2];
assert( true,  __.o.equal( o1, o2 ), "!!simple array, multiple elements unordered" );

var o1 = { a: [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ] };
var o2 = { a: [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ] };
assert( true,  __.o.equal( o1, o2 ), "complex object" );

var o1 = [ { a:1,b:[1] }, { c:[{u:7,l:[[[5]]]}]} ];
var o2 = [ { a:1,b:[1] }, { c:[{u:7,l:[[[4]]]}]} ];
assert( true,  false === __.o.equal( o1, o2 ), "complex object, wrong value" );
var ldiff = {o1:[["diff", "1.c.0.l.0.0.0", 5, 4]],o2:[["diff", "1.c.0.l.0.0.0", 4, 5]]};
assert( true,  __.o.equal( ldiff, __.o.diff( o1, o2 ) ), "->diff" );

var o1 = [ [ {a:1},{a:2},{a:3} ], [ {a:1},{a:2},{a:3} ] ];
var o2 = [ [ {a:1},{a:2},{a:3} ], [ {a:1},{a:2},{a:3} ] ];
assert( true,  __.o.equal( o1, o2 ), "multiple objects duplicated in arrays" );

var o1 = [ [ {a:1},{b:2},{a:3} ], [ {a:1},{b:2},{a:3} ] ];
var o2 = [ [ {a:1},{b:2},{a:3} ], [ {a:1},{b:2},{a:3} ] ];
assert( true,  __.o.equal( o1, o2 ), "multiple objects in arrays" );

var o1 = { fn:function(){var x=1} };
var o2 = { fn:function(){var x=1} };
assert( true,  __.o.equal( o1, o2 ), "functions" );

var o1 = { fn:function(){var x=1} };
var o2 = { fn:function(){var x=1} };
assert( true,  __.o.equal( o1, o2 ), "functions with spaces" );

var o1 = { b:new Date(2018,1,1) };
var o2 = { b:new Date(2018,1,1) };
assert( true,  __.o.equal( o1, o2 ), "same dates" );

var o1 = { b:new Date(2018,1,1) };
var o2 = { b:new Date(2018,1,2) };
assert( true,  false === __.o.equal( o1, o2 ), "different dates" );

assert( true,  false === __.o.equal( {l:[4,3],s:{a:1}}, {l:[3,4],s:[11112]} ), "object with different types" );
assert( true,  __.o.equal( {l:[4,3],s:{a:1}}, {l:[3,4],s:{a:1}} ), "unordered objects" );
assert( true,  false === __.o.equal( [null],[0] ), "null, zero" )
assert( true,  false === __.o.equal( [],[0] ), "undefined, zero" )
assert( true,  false === __.o.equal( [0],[""] ), "zero, empty string" )
assert( true,  false === __.o.equal( [],[""] ), "undefined, empty string" )
assert( true,  false === __.o.equal( [null],[""] ), "null, empty string" )
assert( true,  false === __.o.equal( [null],[0] ), "null, zero" )
assert( true,  false === __.o.equal( [null],[] ), "null, undefined" )
assert( true,  __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
), "obect various types" );
assert( true,  false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:false,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
), "object various types, diff values" );
assert( true,  false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,2),c:-1,d:[[[1]]] }
), "object various types, diff values 2" );
assert( true,  false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:0,d:[[[1]]] }
), "object various types, diff values 3" );
assert( true,  false === __.o.equal(
	  { a:true,b:new Date(2018,1,1),c:-1,d:[[[1]]] }
	, { a:true,b:new Date(2018,1,1),c:0,d:[[[2]]] }
), "object various types, diff values 4" );
assert( true,  __.o.equal(
	  { a:1,b:{c:{d:{e:1}}}}
	, { a:1,b:{c:{d:{e:1}}}}
), "nested objects" );
o1  = {
	_ : [ { x:1, y:2 }, { x:1, y:2 }, { x:1, y:2 } ]
	, a : { a1:true, a2:new Date( 2018,1,1 ), a3:6 }
	, b : {
		b1 : [ 6, 1, 7, 2, 3 ]
		, b2 : {
			  bb1 : 1
			, bb2 : 2
		}
	}
	, c : "by"
	, f : function() { return 'olla' }
}
o2  = {
	_ : [ { x:1, y:2 }, { x:1, y:2 }, { x:1, y:2 } ]
	, a : { a1:true, a2:new Date( 2018,1,1 ), a3:6 }
	, b : {
		b1 : [ 6, 1, 7, 2, 3 ]
		, b2 : {
			  bb1 : 1
			, bb2 : 2
			, bb3 : 3
		}
	}
	, c : "hi"
	, f : function() { return 'olla' }
}

assert( true,  false === __.o.equal( o1, o2 ), "complex object, diff struc" );
delete o2.b.b2.bb3;
assert( true,  false === __.o.equal( o1, o2 ) , "complex object, diff struc 2" );
o2.c = "by";
assert( true,  __.o.equal( o1, o2 ), "complex object, corrected" );
assert( true,  "olla" == o1.f(), "test function of complex object" );
assert( true,  "olla" == o2.f(), "test function of complex object 2" );
var o1 = {a:["a",-1,true]}
var o2 = {a:["a",-1,true]}
assert( true,  __.o.equal( o1, o2 ), "mixed arrays" )

var o1 = {a:[1,true,"a"]}
var o2 = {a:["a",1,true]}
var o1 = ["a",1,2,3,"b"]
var o2 = ["a","b",3,1,2]
assert( true,  __.o.equal( o1, o2 ), "mixed arrays unordered" )

var o1 = [[[["a",1,2,3,"b"]]]];
var o2 = [[[["a","b",3,1,2]]]];
assert( true,  __.o.equal( o1, o2 ), "nested mixed arrays unordered" )

var o1 = {a:[7,2,3,[5,1,2,[8,1,3]]]};
var o2 = {a:[7,2,3,[5,1,2,[8,1,3]]]};
assert( true,  __.o.equal( o1, o2 ), "nested arrays" )

var o1 = [7,2,3,[5,1,2,[8,1,3]]];
var o2 = [7,2,3,[5,1,2,[8,1,3]]];
assert( true,  __.o.equal( o1, o2 ), "nested arrays 1" )

var o1 = [7,2,[5,4,[8,1]]];
var o2 = [7,2,[5,4,[8,1]]];
assert( true,  __.o.equal( o1, o2 ), "nested arrays 2" )

var o1 = {a:[{b:1},[1,2],4,5]}
var o2 = {a:[{b:1},[1,2],4,5]}
assert( true,  __.o.equal( o1, o2 ), "nested arrays complex" )

var o1 = {a:[1,3,1,[false,true,{a:1},["g",-1,99,[1]]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",-1,99,[1]]]]};
assert( true,  __.o.equal( o1, o2 ), "nested ordered arrays complex 2" )

var o1 = {a:[["g",-1,99,[1,3]],3,1,1,{a:1}]};
var o2 = {a:[1,3,1,{a:1},[99,-1,"g",[3,1]]]};
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 3" )

var o1 = {a:[1,3,1,[false,true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,3,1,[false,true,{a:1},["g",99,-1]]]};
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 4" )

var o1 = {a:[1,[true,{a:1},[99,-1,"g"]]]};
var o2 = {a:[1,[true,{a:1},["g",99,-1]]]};
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 5" )

var o1 = {a:[{a:1},[99,-1,"g"]]};
var o2 = {a:[{a:1},["g",99,-1]]};
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 6" )

var o1 = [{a:1},[99,-1,"g"]];
var o2 = [{a:1},["g",99,-1]];
assert( true,  __.o.equal( o1, o2 ), "nested unordered arrays complex 7" )
console.log( "=======", "[OK: " + cOkAssert + "] [ERR: " + cErrAssert + "]", "========" );
</script>
</body>
</html>
